<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Dubbo如何一步一步拿到bean"><meta name="keywords" content="spring,dubbo,dubbox"><meta name="author" content="kazaff,edisondik@gmail.com"><meta name="copyright" content="kazaff"><title>Dubbo如何一步一步拿到bean | kazaff's blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '3.9.0'
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#配置"><span class="toc-number">1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xml-gt-beanDefinition"><span class="toc-number">2.</span> <span class="toc-text">xml -&gt; beanDefinition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#beanDefinition-gt-bean"><span class="toc-number">3.</span> <span class="toc-text">beanDefinition -&gt; bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bean-gt-service"><span class="toc-number">4.</span> <span class="toc-text">bean -&gt; service</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">kazaff</div><div class="author-info__description text-center">coder,leader,tinker</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">198</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">431</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">20</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/banner.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">kazaff's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Dubbo如何一步一步拿到bean</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 1月 26 2015</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/j2ee/">j2ee</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2015/01/26/dubbo如何一步一步拿到bean/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2015/01/26/dubbo如何一步一步拿到bean/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>dubbo依赖了spring提供的现成机制完成了bean的创建，我们来看一下这其中的汰渍。</p>
<a id="more"></a>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>关于dubbo的配置相关细节，官方已经给了一个无比详细的<a href="http://alibaba.github.io/dubbo-doc-static/Configuration+Reference-zh.htm" target="_blank" rel="noopener">文档</a>，<a href="http://alibaba.github.io/dubbo-doc-static/Configs-zh.htm" target="_blank" rel="noopener">文档2</a>。不过由于dubbo可供配置的参数非常多，这也是让我们新手一开始感到最为头疼的，这也是SOA复杂的表象之一。</p>
<h2 id="xml-gt-beanDefinition"><a href="#xml-gt-beanDefinition" class="headerlink" title="xml -&gt; beanDefinition"></a>xml -&gt; beanDefinition</h2><p>对于我这种小学生，需要先补习一个基础知识点：<a href="http://www.cnblogs.com/jifeng/archive/2011/09/14/2176599.html" target="_blank" rel="noopener">基于Spring可扩展Schema提供自定义配置支持</a>。dubbo是依赖spring提供的这种机制来处理配置文件解析的，理解起来没什么难度。</p>
<p>看一下dubbo-congfig的目录结构：</p>
<p><img src="http://pic.yupoo.com/kazaff/EllS0JnY/lFpRv.png" alt></p>
<p>我们来看一下dubbo是如何按照spring提供的机制来处理配置文件的：</p>
<pre><code>#spring.handlers
http\://code.alibabatech.com/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler

#spring.schemas
http\://code.alibabatech.com/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsd
</code></pre><p>这样我们就锁定了要分析的类：</p>
<pre><code>package com.alibaba.dubbo.config.spring.schema;

public class DubboNamespaceHandler extends NamespaceHandlerSupport {

    static {
        Version.checkDuplicate(DubboNamespaceHandler.class); //确保系统中只存在一份解析处理器类定义
    }

    public void init() {
        registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true));
        registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true));
        registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true));
        registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true));
        registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true));
        registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true));
        registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true));
        registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true));
        registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false));
        registerBeanDefinitionParser(&quot;annotation&quot;, new DubboBeanDefinitionParser(AnnotationBean.class, true));
    }
}
</code></pre><p>按照spring提供的机制，dubbo把每个自定义的可使用配置元素和对应的解析器绑定到一起。而真正负责把配置文件中声明的内容解析成对应的BeanDefinition（可以想象为Bean的模子）是靠<code>DubboBeanDefinitionParser.parse</code>类完成，我们就来严肃的分析一下这个方法。</p>
<pre><code>/**
 * AbstractBeanDefinitionParser
 * 
 * @author william.liangf
 * @export
 */
public class DubboBeanDefinitionParser implements BeanDefinitionParser {

    private static final Logger logger = LoggerFactory.getLogger(DubboBeanDefinitionParser.class);

    private final Class&lt;?&gt; beanClass;

    private final boolean required;

    public DubboBeanDefinitionParser(Class&lt;?&gt; beanClass, boolean required) {
        this.beanClass = beanClass;
        this.required = required;
    }

    public BeanDefinition parse(Element element, ParserContext parserContext) {
        return parse(element, parserContext, beanClass, required);
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) {
        //初始化BeanDefiniion
        RootBeanDefinition beanDefinition = new RootBeanDefinition();
        beanDefinition.setBeanClass(beanClass);
        beanDefinition.setLazyInit(false);

        String id = element.getAttribute(&quot;id&quot;);
        if ((id == null || id.length() == 0) &amp;&amp; required) {
            String generatedBeanName = element.getAttribute(&quot;name&quot;);
            if (generatedBeanName == null || generatedBeanName.length() == 0) {
                if (ProtocolConfig.class.equals(beanClass)) {   //如果当前解析的类型是ProtocolConfig，则设置默认id为dubbo
                    generatedBeanName = &quot;dubbo&quot;;
                } else {
                    generatedBeanName = element.getAttribute(&quot;interface&quot;);  //其他情况，默认id为接口类型
                }
            }
            if (generatedBeanName == null || generatedBeanName.length() == 0) {
                generatedBeanName = beanClass.getName();    //如果该节点没有interface属性（包含：registry,monitor,provider,consumer），则使用该节点的类型为id值
            }
            id = generatedBeanName; 
            int counter = 2;
            while(parserContext.getRegistry().containsBeanDefinition(id)) { //生成不重复的id
                id = generatedBeanName + (counter ++);
            }
        }
        if (id != null &amp;&amp; id.length() &gt; 0) {    //目前这个判断不知道啥意义，目测必定会返回true
            if (parserContext.getRegistry().containsBeanDefinition(id))  {  //这个判断应该用于防止并发
                throw new IllegalStateException(&quot;Duplicate spring bean id &quot; + id);
            }
            //注册beanDefinition，BeanDefinitionRegistry相当于一张注册表
            parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);
            beanDefinition.getPropertyValues().addPropertyValue(&quot;id&quot;, id);
        }
        //下面这几个if-else分别针对不同类型做特殊处理
        if (ProtocolConfig.class.equals(beanClass)) {
            //这段代码的逻辑是用来适配：当&lt;dubbo:protocol&gt;声明出现在配置文件中使用该协议的bean声明的后面时，解决它们之间的依赖关系的。
            for (String name : parserContext.getRegistry().getBeanDefinitionNames()) {
                BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);
                PropertyValue property = definition.getPropertyValues().getPropertyValue(&quot;protocol&quot;);
                if (property != null) {
                    Object value = property.getValue();
                    //如果被检查的bean确实使用当前协议，则建立它们之间的依赖关系
                    if (value instanceof ProtocolConfig &amp;&amp; id.equals(((ProtocolConfig) value).getName())) {
                        definition.getPropertyValues().addPropertyValue(&quot;protocol&quot;, new RuntimeBeanReference(id));
                    }
                }
            }
        } else if (ServiceBean.class.equals(beanClass)) {
            String className = element.getAttribute(&quot;class&quot;);   //虽然文档上没有标注该配置支持class参数，但是在dubbo.xsd上却能看到这个属性的定义，类似这样的情况还有很多。
            if(className != null &amp;&amp; className.length() &gt; 0) {   //下面的处理方式应该算是语法糖吧，它支持直接把定义bean和创建serviceConfig压缩成一行
                RootBeanDefinition classDefinition = new RootBeanDefinition();
                classDefinition.setBeanClass(ReflectUtils.forName(className));
                classDefinition.setLazyInit(false);
                parseProperties(element.getChildNodes(), classDefinition);  //完成bean的初始化工作（注入等）
                beanDefinition.getPropertyValues().addPropertyValue(&quot;ref&quot;, new BeanDefinitionHolder(classDefinition, id + &quot;Impl&quot;)); //关联bean和serviceConfig
            }
        } else if (ProviderConfig.class.equals(beanClass)) {    //按照providerConfig的定义解析并关联其影响的相关serviceConfig
            parseNested(element, parserContext, ServiceBean.class, true, &quot;service&quot;, &quot;provider&quot;, id, beanDefinition);
        } else if (ConsumerConfig.class.equals(beanClass)) {    //按照consumerConfig的定义解析并关联其影响的相关referenceConfig
            parseNested(element, parserContext, ReferenceBean.class, false, &quot;reference&quot;, &quot;consumer&quot;, id, beanDefinition);
        }
        Set&lt;String&gt; props = new HashSet&lt;String&gt;();
        ManagedMap parameters = null;
        for (Method setter : beanClass.getMethods()) {  //利用反射拿到指定类型的所有用于注入的方法
            String name = setter.getName();
            if (name.length() &gt; 3 &amp;&amp; name.startsWith(&quot;set&quot;)
                    &amp;&amp; Modifier.isPublic(setter.getModifiers())
                    &amp;&amp; setter.getParameterTypes().length == 1) {    //注入方法的特征是：以set字母开头，是公共方法，且参数个数为1
                Class&lt;?&gt; type = setter.getParameterTypes()[0];
                String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), &quot;-&quot;);    //把方法名字的驼峰格式改成-分割格式
                props.add(property);
                Method getter = null;
                try {
                    getter = beanClass.getMethod(&quot;get&quot; + name.substring(3), new Class&lt;?&gt;[0]);
                } catch (NoSuchMethodException e) {
                    try {
                        getter = beanClass.getMethod(&quot;is&quot; + name.substring(3), new Class&lt;?&gt;[0]);
                    } catch (NoSuchMethodException e2) {
                    }
                }
                if (getter == null 
                        || ! Modifier.isPublic(getter.getModifiers())
                        || ! type.equals(getter.getReturnType())) { //如果没有满足条件的对应getter方法存在，则直接跳过该setter方法
                    continue;
                }

                if (&quot;parameters&quot;.equals(property)) {    //从配置文件中解析出parameter配置，用于配置自定义参数，该配置项将作为扩展点设置自定义参数使用，parameter的值当string类型解析
                    parameters = parseParameters(element.getChildNodes(), beanDefinition);
                } else if (&quot;methods&quot;.equals(property)) {    //注入对应的method配置
                    parseMethods(id, element.getChildNodes(), beanDefinition, parserContext);
                } else if (&quot;arguments&quot;.equals(property)) {  //为method注入对应的argument配置
                    parseArguments(id, element.getChildNodes(), beanDefinition, parserContext);
                } else {
                    String value = element.getAttribute(property);  //检查该setter方法所适配要注入的属性是否在配置中明确定义
                    if (value != null) {    //若存在定义，则完成其注入解析
                        value = value.trim();
                        if (value.length() &gt; 0) {
                            if (&quot;registry&quot;.equals(property) &amp;&amp; RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) {   //处理无注册中心的情况
                                RegistryConfig registryConfig = new RegistryConfig();
                                registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);
                                beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig);
                            } else if (&quot;registry&quot;.equals(property) &amp;&amp; value.indexOf(&apos;,&apos;) != -1) {   //处理多注册中心的情况
                                parseMultiRef(&quot;registries&quot;, value, beanDefinition, parserContext);
                            } else if (&quot;provider&quot;.equals(property) &amp;&amp; value.indexOf(&apos;,&apos;) != -1) {   //处理继承多个provider的情况，缺使用第一个provider配置
                                parseMultiRef(&quot;providers&quot;, value, beanDefinition, parserContext);
                            } else if (&quot;protocol&quot;.equals(property) &amp;&amp; value.indexOf(&apos;,&apos;) != -1) {   //处理多协议暴露
                                parseMultiRef(&quot;protocols&quot;, value, beanDefinition, parserContext);
                            } else {
                                Object reference;
                                if (isPrimitive(type)) {    //如果setter的参数类型为jdk原始类型，直接当string注入到对应属性中去
                                    if (&quot;async&quot;.equals(property) &amp;&amp; &quot;false&quot;.equals(value)
                                            || &quot;timeout&quot;.equals(property) &amp;&amp; &quot;0&quot;.equals(value)
                                            || &quot;delay&quot;.equals(property) &amp;&amp; &quot;0&quot;.equals(value)
                                            || &quot;version&quot;.equals(property) &amp;&amp; &quot;0.0.0&quot;.equals(value)
                                            || &quot;stat&quot;.equals(property) &amp;&amp; &quot;-1&quot;.equals(value)
                                            || &quot;reliable&quot;.equals(property) &amp;&amp; &quot;false&quot;.equals(value)) {
                                        // 兼容旧版本xsd中的default值
                                        value = null;
                                    }
                                    reference = value;
                                } else if (&quot;protocol&quot;.equals(property) 
                                        &amp;&amp; ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(value)   //是否存在指定的扩展点定义
                                        &amp;&amp; (! parserContext.getRegistry().containsBeanDefinition(value) //检查当前解析出的要使用协议对应的protocolConfig是否已经被初始化
                                                || ! ProtocolConfig.class.getName().equals(parserContext.getRegistry().getBeanDefinition(value).getBeanClassName()))) {
                                    if (&quot;dubbo:provider&quot;.equals(element.getTagName())) {
                                        logger.warn(&quot;Recommended replace &lt;dubbo:provider protocol=\&quot;&quot; + value + &quot;\&quot; ... /&gt; to &lt;dubbo:protocol name=\&quot;&quot; + value + &quot;\&quot; ... /&gt;&quot;);
                                    }
                                    // 兼容旧版本配置
                                    ProtocolConfig protocol = new ProtocolConfig();
                                    protocol.setName(value);
                                    reference = protocol;
                                } else if (&quot;monitor&quot;.equals(property) 
                                        &amp;&amp; (! parserContext.getRegistry().containsBeanDefinition(value)
                                                || ! MonitorConfig.class.getName().equals(parserContext.getRegistry().getBeanDefinition(value).getBeanClassName()))) {
                                    // 兼容旧版本配置
                                    reference = convertMonitor(value);
                                } else if (&quot;onreturn&quot;.equals(property)) {   //对应methodConfig中的返回拦截
                                    int index = value.lastIndexOf(&quot;.&quot;);
                                    String returnRef = value.substring(0, index);
                                    String returnMethod = value.substring(index + 1);
                                    reference = new RuntimeBeanReference(returnRef);
                                    beanDefinition.getPropertyValues().addPropertyValue(&quot;onreturnMethod&quot;, returnMethod);
                                } else if (&quot;onthrow&quot;.equals(property)) {    //对应methodConfig中的异常拦截
                                    int index = value.lastIndexOf(&quot;.&quot;);
                                    String throwRef = value.substring(0, index);
                                    String throwMethod = value.substring(index + 1);
                                    reference = new RuntimeBeanReference(throwRef);
                                    beanDefinition.getPropertyValues().addPropertyValue(&quot;onthrowMethod&quot;, throwMethod);
                                } else {
                                    if (&quot;ref&quot;.equals(property) &amp;&amp; parserContext.getRegistry().containsBeanDefinition(value)) {
                                        BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);
                                        if (! refBean.isSingleton()) {
                                            throw new IllegalStateException(&quot;The exported service ref &quot; + value + &quot; must be singleton! Please set the &quot; + value + &quot; bean scope to singleton, eg: &lt;bean id=\&quot;&quot; + value+ &quot;\&quot; scope=\&quot;singleton\&quot; ...&gt;&quot;);
                                        }
                                    }
                                    reference = new RuntimeBeanReference(value);
                                }
                                beanDefinition.getPropertyValues().addPropertyValue(property, reference);
                            }
                        }
                    }
                }
            }
        }
        NamedNodeMap attributes = element.getAttributes();
        int len = attributes.getLength();
        for (int i = 0; i &lt; len; i++) {
            Node node = attributes.item(i);
            String name = node.getLocalName();
            if (! props.contains(name)) {   //处理配置中声明的没有满足注入条件的剩余属性
                if (parameters == null) {
                    parameters = new ManagedMap();
                }
                String value = node.getNodeValue();
                parameters.put(name, new TypedStringValue(value, String.class));
            }
        }
        if (parameters != null) {
            beanDefinition.getPropertyValues().addPropertyValue(&quot;parameters&quot;, parameters);
        }
        return beanDefinition;
    }

    private static final Pattern GROUP_AND_VERION = Pattern.compile(&quot;^[\\-.0-9_a-zA-Z]+(\\:[\\-.0-9_a-zA-Z]+)?$&quot;);

    protected static MonitorConfig convertMonitor(String monitor) {
        if (monitor == null || monitor.length() == 0) {
            return null;
        }
        if (GROUP_AND_VERION.matcher(monitor).matches()) {
            String group;
            String version;
            int i = monitor.indexOf(&apos;:&apos;);
            if (i &gt; 0) {
                group = monitor.substring(0, i);
                version = monitor.substring(i + 1);
            } else {
                group = monitor;
                version = null;
            }
            MonitorConfig monitorConfig = new MonitorConfig();
            monitorConfig.setGroup(group);
            monitorConfig.setVersion(version);
            return monitorConfig;
        }
        return null;
    }

    private static boolean isPrimitive(Class&lt;?&gt; cls) {
        return cls.isPrimitive() || cls == Boolean.class || cls == Byte.class
                || cls == Character.class || cls == Short.class || cls == Integer.class
                || cls == Long.class || cls == Float.class || cls == Double.class
                || cls == String.class || cls == Date.class || cls == Class.class;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private static void parseMultiRef(String property, String value, RootBeanDefinition beanDefinition,
            ParserContext parserContext) {
        String[] values = value.split(&quot;\\s*[,]+\\s*&quot;);
        ManagedList list = null;
        for (int i = 0; i &lt; values.length; i++) {
            String v = values[i];
            if (v != null &amp;&amp; v.length() &gt; 0) {
                if (list == null) {
                    list = new ManagedList();
                }
                list.add(new RuntimeBeanReference(v));
            }
        }
        beanDefinition.getPropertyValues().addPropertyValue(property, list);
    }

    private static void parseNested(Element element,
                                    ParserContext parserContext,
                                    Class&lt;?&gt; beanClass,
                                    boolean required,
                                    String tag,
                                    String property,
                                    String ref,
                                    BeanDefinition beanDefinition) {
        NodeList nodeList = element.getChildNodes();
        if (nodeList != null &amp;&amp; nodeList.getLength() &gt; 0) {
            boolean first = true;
            for (int i = 0; i &lt; nodeList.getLength(); i++) {
                Node node = nodeList.item(i);
                if (node instanceof Element) {
                    if (tag.equals(node.getNodeName())
                            || tag.equals(node.getLocalName())) {
                        if (first) {
                            //如果该providerBean没有设置default开关，且子节点中定义了serviceBean，则明确赋值该参数为false，也就是说该providerBean只作为其子serviceBean节点的默认协议
                            //这样就不会让该providerBean的作用范围盲目扩大（成为所有serviceBean的默认协议）
                            first = false;
                            String isDefault = element.getAttribute(&quot;default&quot;);
                            if (isDefault == null || isDefault.length() == 0) {
                                beanDefinition.getPropertyValues().addPropertyValue(&quot;default&quot;, &quot;false&quot;);
                            }
                        }
                        //所有子serviceBean定义节点全部解析并引用该providerBean作为默认值配置
                        BeanDefinition subDefinition = parse((Element) node, parserContext, beanClass, required);
                        if (subDefinition != null &amp;&amp; ref != null &amp;&amp; ref.length() &gt; 0) {
                            subDefinition.getPropertyValues().addPropertyValue(property, new RuntimeBeanReference(ref));
                        }
                    }
                }
            }
        }
    }

    private static void parseProperties(NodeList nodeList, RootBeanDefinition beanDefinition) {
        if (nodeList != null &amp;&amp; nodeList.getLength() &gt; 0) {
            for (int i = 0; i &lt; nodeList.getLength(); i++) {
                Node node = nodeList.item(i);
                if (node instanceof Element) {
                    if (&quot;property&quot;.equals(node.getNodeName())
                            || &quot;property&quot;.equals(node.getLocalName())) {
                        String name = ((Element) node).getAttribute(&quot;name&quot;);
                        if (name != null &amp;&amp; name.length() &gt; 0) {
                            String value = ((Element) node).getAttribute(&quot;value&quot;);  //java基础类型
                            String ref = ((Element) node).getAttribute(&quot;ref&quot;);  //引用其他bean
                            if (value != null &amp;&amp; value.length() &gt; 0) {
                                beanDefinition.getPropertyValues().addPropertyValue(name, value);
                            } else if (ref != null &amp;&amp; ref.length() &gt; 0) {
                                beanDefinition.getPropertyValues().addPropertyValue(name, new RuntimeBeanReference(ref));
                            } else {
                                throw new UnsupportedOperationException(&quot;Unsupported &lt;property name=\&quot;&quot; + name + &quot;\&quot;&gt; sub tag, Only supported &lt;property name=\&quot;&quot; + name + &quot;\&quot; ref=\&quot;...\&quot; /&gt; or &lt;property name=\&quot;&quot; + name + &quot;\&quot; value=\&quot;...\&quot; /&gt;&quot;);
                            }
                        }
                    }
                }
            }
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private static ManagedMap parseParameters(NodeList nodeList, RootBeanDefinition beanDefinition) {   //解析参数配置，用于配置自定义参数，该配置项将作为扩展点设置自定义参数使用。
        if (nodeList != null &amp;&amp; nodeList.getLength() &gt; 0) {
            ManagedMap parameters = null;
            for (int i = 0; i &lt; nodeList.getLength(); i++) {
                Node node = nodeList.item(i);
                if (node instanceof Element) {
                    if (&quot;parameter&quot;.equals(node.getNodeName())
                            || &quot;parameter&quot;.equals(node.getLocalName())) {
                        if (parameters == null) {
                            parameters = new ManagedMap();
                        }
                        String key = ((Element) node).getAttribute(&quot;key&quot;);
                        String value = ((Element) node).getAttribute(&quot;value&quot;);
                        boolean hide = &quot;true&quot;.equals(((Element) node).getAttribute(&quot;hide&quot;));
                        if (hide) {
                            key = Constants.HIDE_KEY_PREFIX + key;
                        }
                        parameters.put(key, new TypedStringValue(value, String.class)); //注意parameter的值都是string类型
                    }
                }
            }
            return parameters;
        }
        return null;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private static void parseMethods(String id, NodeList nodeList, RootBeanDefinition beanDefinition,
                              ParserContext parserContext) {
        if (nodeList != null &amp;&amp; nodeList.getLength() &gt; 0) {
            ManagedList methods = null;
            for (int i = 0; i &lt; nodeList.getLength(); i++) {
                Node node = nodeList.item(i);
                if (node instanceof Element) {
                    Element element = (Element) node;
                    if (&quot;method&quot;.equals(node.getNodeName()) || &quot;method&quot;.equals(node.getLocalName())) {
                        String methodName = element.getAttribute(&quot;name&quot;);
                        if (methodName == null || methodName.length() == 0) {   //name为必填项，这一点在文档里也表明
                            throw new IllegalStateException(&quot;&lt;dubbo:method&gt; name attribute == null&quot;);
                        }
                        if (methods == null) {
                            methods = new ManagedList();
                        }
                        BeanDefinition methodBeanDefinition = parse(((Element) node),
                                parserContext, MethodConfig.class, false);  //解析methodConfig
                        String name = id + &quot;.&quot; + methodName;    //注意这里，方法的名称前会加上bean的id
                        BeanDefinitionHolder methodBeanDefinitionHolder = new BeanDefinitionHolder(
                                methodBeanDefinition, name);
                        methods.add(methodBeanDefinitionHolder);
                    }
                }
            }
            if (methods != null) {
                beanDefinition.getPropertyValues().addPropertyValue(&quot;methods&quot;, methods);    //关联bean和其method
            }
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private static void parseArguments(String id, NodeList nodeList, RootBeanDefinition beanDefinition,
                              ParserContext parserContext) {
        if (nodeList != null &amp;&amp; nodeList.getLength() &gt; 0) {
            ManagedList arguments = null;
            for (int i = 0; i &lt; nodeList.getLength(); i++) {
                Node node = nodeList.item(i);
                if (node instanceof Element) {
                    Element element = (Element) node;
                    if (&quot;argument&quot;.equals(node.getNodeName()) || &quot;argument&quot;.equals(node.getLocalName())) {
                        String argumentIndex = element.getAttribute(&quot;index&quot;);   //不清楚这里为何没有必填校验
                        if (arguments == null) {
                            arguments = new ManagedList();
                        }
                        BeanDefinition argumentBeanDefinition = parse(((Element) node),
                                parserContext, ArgumentConfig.class, false);
                        String name = id + &quot;.&quot; + argumentIndex;
                        BeanDefinitionHolder argumentBeanDefinitionHolder = new BeanDefinitionHolder(
                                argumentBeanDefinition, name);
                        arguments.add(argumentBeanDefinitionHolder);
                    }
                }
            }
            if (arguments != null) {
                beanDefinition.getPropertyValues().addPropertyValue(&quot;arguments&quot;, arguments);    //关联arguments和其method
            }
        }
    }

}
</code></pre><p>现在，我们的dubbo就已经把配置文件中定义的bean全部解析成对应的<strong>beanDefinition</strong>，为spring的getBean做好准备工作。</p>
<h2 id="beanDefinition-gt-bean"><a href="#beanDefinition-gt-bean" class="headerlink" title="beanDefinition -&gt; bean"></a>beanDefinition -&gt; bean</h2><p>其实也就是从beanDefinition转换成bean的过程，我在网上找了<a href="http://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/" target="_blank" rel="noopener">一幅图</a>，可以辅助我们了解spring内部是如何初始化bean的：</p>
<p><img src="http://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/origin_image012.gif" alt></p>
<p>这里也有一篇不错的<a href="http://songzi0206.iteye.com/blog/1430239#show-last-Point" target="_blank" rel="noopener">文章</a>，从代码的角度描述了spring内部是如何使用BeanDefinition生成Bean的，dubbo就是委托给spring来管理bean的生命周期的。</p>
<p>那么dubbo自定义schemas所产生的beanDefinition，spring是如何将其转换成dubbo需要的bean呢？毕竟我们从上面的解析中看到，解析生成的beanDefinition中包含太多dubbo特殊的配置方式。这里我有两个猜测：</p>
<ul>
<li>dubbo在spring提供的相关扩展点上实现了自己的getBean逻辑，可我却在dubbo的源码中找不到对应实现；</li>
<li><strong>spring解析生成的beanDefinition并没有dubbo特殊性，交给默认的BeanFactory没啥问题</strong>（这都怪我spring太差啊~）</li>
</ul>
<p>带着疑问我进行了严酷的单步调试，事实证明是第二种路数。到目前为止，dubbo已经按照我们提供的配置文件把所有需要的<strong>bean</strong>初始化完成，这部分基本上都是交给spring来搞定的。</p>
<p>这还不够，我们还不知道这些bean是怎么服务于业务！</p>
<h2 id="bean-gt-service"><a href="#bean-gt-service" class="headerlink" title="bean -&gt; service"></a>bean -&gt; service</h2><p>那么到底是哪些bean最终会被dubbo直接拿来使用呢？其实<code>DubboNamespaceHandler.init</code>中的那些就是答案。我们先看一下这些类的关系：</p>
<p><img src="http://alibaba.github.io/dubbo-doc-static/dubbo-config.jpg-version=1&amp;modificationDate=1330708121000.jpg" alt></p>
<p>其实这么复杂的关系最终都会被转换成字符串以<code>URL</code>的形式交给dubbo的底层最终暴露成服务。我们先来重点看一下<code>ServiceBean</code>的实现，了解一下服务提供方的细节。</p>
<p>按照上面uml图来看，这些<strong>xxxConfig</strong>类的关系已经很清楚了（谁继承谁，谁聚合谁，谁依赖谁）。不过图里并没有出现我们的目标：<strong>ServiceBean</strong>，补充下图：</p>
<p><img src="http://pic.yupoo.com/kazaff/En3pJXbV/NqlfS.png" alt></p>
<p>除了继承父类外，我们也要注意<code>ServiceBean</code>实现的相关接口：</p>
<pre><code>public class ServiceBean&lt;T&gt; extends ServiceConfig&lt;T&gt; implements InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener, BeanNameAware 
</code></pre><p>这里我们着重看<code>InitializingBean</code>接口，该接口为spring留给开发者的一个hook，用来执行初始化bean的个性化逻辑的回调，详情可以看这篇<a href="http://www.cnblogs.com/zrtqsk/p/3735273.html#show-last-Point" target="_blank" rel="noopener">文章</a>。</p>
<p>既然我们的<code>ServiceBean</code>实现了这个接口，意味着当spring进行容器初始化任务过程中，会执行我们在<code>ServiceBean.afterPropertiesSet</code>方法中安排的逻辑，这也是bean导出为服务的关键入口，先把本尊注释过的代码贴出来：</p>
<pre><code>public class ServiceBean&lt;T&gt; extends ServiceConfig&lt;T&gt; implements InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener, BeanNameAware {

    private static final long serialVersionUID = 213195494150089726L;

    private static transient ApplicationContext SPRING_CONTEXT;

    private transient ApplicationContext applicationContext;

    private transient String beanName;

    private transient boolean supportedApplicationListener;

    public ServiceBean() {
        super();
    }

    public ServiceBean(Service service) {
        super(service);
    }

    public static ApplicationContext getSpringContext() {
        return SPRING_CONTEXT;
    }

    public void setApplicationContext(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;

        //把该应用上下文存储在SpringExtensionFactory（dubbo的SPI扩展点机制）中
        //把原先spring通过ApplicationContext获取bean的方式封装了一下，以dubbo统一的SPI扩展点机制风格接口暴露给业务使用
        SpringExtensionFactory.addApplicationContext(applicationContext);
        if (applicationContext != null) {
            SPRING_CONTEXT = applicationContext;
            try {
                //把所有serviceBean都加入到ApplicationContext的事件通知中
                Method method = applicationContext.getClass().getMethod(&quot;addApplicationListener&quot;, new Class&lt;?&gt;[]{ApplicationListener.class}); // 兼容Spring2.0.1
                method.invoke(applicationContext, new Object[] {this});
                supportedApplicationListener = true;
            } catch (Throwable t) {
                if (applicationContext instanceof AbstractApplicationContext) {
                    try {
                        Method method = AbstractApplicationContext.class.getDeclaredMethod(&quot;addListener&quot;, new Class&lt;?&gt;[]{ApplicationListener.class}); // 兼容Spring2.0.1
                        if (! method.isAccessible()) {
                            method.setAccessible(true);
                        }
                        method.invoke(applicationContext, new Object[] {this});
                        supportedApplicationListener = true;
                    } catch (Throwable t2) {
                    }
                }
            }
        }
    }

    public void setBeanName(String name) {
        this.beanName = name;
    }

    //如果配置serviceBean时声明了延迟暴露（例如：&lt;dubbo:service delay=&quot;-1&quot; /&gt;），则会依赖监听spring提供的相关事件来触发export
    public void onApplicationEvent(ApplicationEvent event) {
        if (ContextRefreshedEvent.class.getName().equals(event.getClass().getName())) { //监听ContextRefreshedEvent事件（容器发生初始化或更新时触发）
            if (isDelay() &amp;&amp; ! isExported() &amp;&amp; ! isUnexported()) {  //如果已导出过或者已手工放弃导出则不会执行export逻辑
                if (logger.isInfoEnabled()) {
                    logger.info(&quot;The service ready on spring started. service: &quot; + getInterface());
                }
                export();
            }
        }
    }

    private boolean isDelay() {
        Integer delay = getDelay();
        ProviderConfig provider = getProvider();
        if (delay == null &amp;&amp; provider != null) {    //若没有明确指定延迟，则尝试继承provider配置
            delay = provider.getDelay();
        }
        return supportedApplicationListener &amp;&amp; (delay == null || delay.intValue() == -1);   //注意这里对delay值的条件很奇怪，如果我设置delay为5000毫秒时，难道不算是延迟么？请参考\com\alibaba\dubbo\config\ServiceConfig.java的132行
    }

    @SuppressWarnings({ &quot;unchecked&quot;, &quot;deprecation&quot; })
    public void afterPropertiesSet() throws Exception {
        if (getProvider() == null) {    //如果当前serviceBean并没有指定provider，则下面的逻辑为其指定默认的providerConfig（如果存在的话）
            Map&lt;String, ProviderConfig&gt; providerConfigMap = applicationContext == null ? null  : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig.class, false, false);
            if (providerConfigMap != null &amp;&amp; providerConfigMap.size() &gt; 0) {
                Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == null ? null  : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, false, false);
                if ((protocolConfigMap == null || protocolConfigMap.size() == 0)
                        &amp;&amp; providerConfigMap.size() &gt; 1) { // 兼容旧版本
                    List&lt;ProviderConfig&gt; providerConfigs = new ArrayList&lt;ProviderConfig&gt;();
                    for (ProviderConfig config : providerConfigMap.values()) {
                        if (config.isDefault() != null &amp;&amp; config.isDefault().booleanValue()) {  //把所有指定为默认范围的providerConfig拿到，跳转到下面
                            providerConfigs.add(config);
                        }
                    }
                    if (providerConfigs.size() &gt; 0) {
                        setProviders(providerConfigs);  //接着上面，把所有指定为默认范围的providerConfig中与protocol相关的配置封装成protocolConfig并存入serviceConfig对应属性中
                    }
                } else {
                    ProviderConfig providerConfig = null;
                    for (ProviderConfig config : providerConfigMap.values()) {
                        //如果某个provider配置包含子node（ServiceBean），且没有明确指定default，也会被当成默认配置么？这个疑问请参看：com\alibaba\dubbo\config\spring\schema\DubboBeanDefinitionParser.java中330行注解
                        if (config.isDefault() == null || config.isDefault().booleanValue()) {
                            if (providerConfig != null) {   //只能有一个provider设置为默认
                                throw new IllegalStateException(&quot;Duplicate provider configs: &quot; + providerConfig + &quot; and &quot; + config);
                            }
                            providerConfig = config;
                        }
                    }
                    if (providerConfig != null) {
                        setProvider(providerConfig);    //为serviceBean绑定继承的providerConfig
                    }
                }
            }
        }
        //如果当前serviceBean并没有指定Application且其继承的provider也没有指定Application，则下面的逻辑为其指定默认的applicationConfig（如果存在的话）
        if (getApplication() == null
                &amp;&amp; (getProvider() == null || getProvider().getApplication() == null)) {
            Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false);
            if (applicationConfigMap != null &amp;&amp; applicationConfigMap.size() &gt; 0) {
                ApplicationConfig applicationConfig = null;
                for (ApplicationConfig config : applicationConfigMap.values()) {
                    if (config.isDefault() == null || config.isDefault().booleanValue()) {
                        if (applicationConfig != null) {    //只能有一个Application设置为默认
                            throw new IllegalStateException(&quot;Duplicate application configs: &quot; + applicationConfig + &quot; and &quot; + config);
                        }
                        applicationConfig = config;
                    }
                }
                if (applicationConfig != null) {
                    setApplication(applicationConfig);  //为serviceBean绑定applicationConfig
                }
            }
        }
        //如果当前serviceBean并没有指定Module且其继承的provider也没有指定Module，则下面的逻辑为其指定默认的moduleConfig（如果存在的话）
        if (getModule() == null
                &amp;&amp; (getProvider() == null || getProvider().getModule() == null)) {
            Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, false, false);
            if (moduleConfigMap != null &amp;&amp; moduleConfigMap.size() &gt; 0) {
                ModuleConfig moduleConfig = null;
                for (ModuleConfig config : moduleConfigMap.values()) {
                    if (config.isDefault() == null || config.isDefault().booleanValue()) {
                        if (moduleConfig != null) { //只能有一个Module设置为默认
                            throw new IllegalStateException(&quot;Duplicate module configs: &quot; + moduleConfig + &quot; and &quot; + config);
                        }
                        moduleConfig = config;
                    }
                }
                if (moduleConfig != null) {
                    setModule(moduleConfig);    //为serviceBean绑定moduleConfig
                }
            }
        }
        //如果当前serviceBean并没有指定Registry且其继承的provider,application也没有指定Registry，则下面的逻辑为其指定默认的registryConfig（如果存在的话）
        if ((getRegistries() == null || getRegistries().size() == 0)
                &amp;&amp; (getProvider() == null || getProvider().getRegistries() == null || getProvider().getRegistries().size() == 0)
                &amp;&amp; (getApplication() == null || getApplication().getRegistries() == null || getApplication().getRegistries().size() == 0)) {
            Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, false, false);
            if (registryConfigMap != null &amp;&amp; registryConfigMap.size() &gt; 0) {
                List&lt;RegistryConfig&gt; registryConfigs = new ArrayList&lt;RegistryConfig&gt;();
                for (RegistryConfig config : registryConfigMap.values()) {
                    if (config.isDefault() == null || config.isDefault().booleanValue()) {  //允许为serviceBean指定多个Registry
                        registryConfigs.add(config);
                    }
                }
                if (registryConfigs != null &amp;&amp; registryConfigs.size() &gt; 0) {
                    super.setRegistries(registryConfigs);
                }
            }
        }
        //如果当前serviceBean并没有指定Monitor且其继承的provider,application也没有指定Monitor，则下面的逻辑为其指定默认的monitorConfig（如果存在的话）
        if (getMonitor() == null
                &amp;&amp; (getProvider() == null || getProvider().getMonitor() == null)
                &amp;&amp; (getApplication() == null || getApplication().getMonitor() == null)) {
            Map&lt;String, MonitorConfig&gt; monitorConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, false, false);
            if (monitorConfigMap != null &amp;&amp; monitorConfigMap.size() &gt; 0) {
                MonitorConfig monitorConfig = null;
                for (MonitorConfig config : monitorConfigMap.values()) {
                    if (config.isDefault() == null || config.isDefault().booleanValue()) {
                        if (monitorConfig != null) {    //只能有一个Monitor设置为默认
                            throw new IllegalStateException(&quot;Duplicate monitor configs: &quot; + monitorConfig + &quot; and &quot; + config);
                        }
                        monitorConfig = config;
                    }
                }
                if (monitorConfig != null) {
                    setMonitor(monitorConfig);  //为serviceBean绑定monitorConfig
                }
            }
        }
        //如果当前serviceBean并没有指定Protocol且其继承的provider也没有指定Protocol，则下面的逻辑为其指定默认的protocolConfig（如果存在的话）
        if ((getProtocols() == null || getProtocols().size() == 0)
                &amp;&amp; (getProvider() == null || getProvider().getProtocols() == null || getProvider().getProtocols().size() == 0)) {
            Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == null ? null  : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, false, false);
            if (protocolConfigMap != null &amp;&amp; protocolConfigMap.size() &gt; 0) {
                List&lt;ProtocolConfig&gt; protocolConfigs = new ArrayList&lt;ProtocolConfig&gt;();
                for (ProtocolConfig config : protocolConfigMap.values()) {
                    if (config.isDefault() == null || config.isDefault().booleanValue()) {
                        protocolConfigs.add(config);    //允许为serviceBean指定多个Protocol
                    }
                }
                if (protocolConfigs != null &amp;&amp; protocolConfigs.size() &gt; 0) {
                    super.setProtocols(protocolConfigs);
                }
            }
        }
        //设置服务路径，默认使用的是该bean在spring容器中注册的beanName，这也是该类继承BeanNameAware的原因
        if (getPath() == null || getPath().length() == 0) {
            if (beanName != null &amp;&amp; beanName.length() &gt; 0 
                    &amp;&amp; getInterface() != null &amp;&amp; getInterface().length() &gt; 0
                    &amp;&amp; beanName.startsWith(getInterface())) {
                setPath(beanName);
            }
        }
        //若不是延迟加载，就上演好戏
        if (! isDelay()) {
            export();
        }
    }

    public void destroy() throws Exception {
        unexport();
    }
}
</code></pre><p>这里就明白为何ServiceBean和其父类ServiceConfig不在同一个包内，因为前者是为了适配spring而提供的适配器。ServiceBean依赖spring提供的相关hook接口完成了bean的初始化，最终<code>export</code>逻辑交给<code>ServiceConfig</code>来完成，这才是dubbo的核心服务配置类，这也解释了为何上面UML图中没有画ServiceBean的原因。</p>
<p>我们继续跟着线索来看一下<code>ServiceConfig.export</code>：</p>
<pre><code>public synchronized void export() {
    //从provider中继承一些必要但没有明确设置的参数
    if (provider != null) {
        if (export == null) {
            export = provider.getExport();
        }
        if (delay == null) {
            delay = provider.getDelay();
        }
    }
    if (export != null &amp;&amp; ! export.booleanValue()) {    //如果不需要暴露该服务，则就此结束
        return;
    }
    if (delay != null &amp;&amp; delay &gt; 0) {   //如果明确指定了想要延迟的时间差，则依赖线程休眠来完成延迟暴露，delay的值只有为-1或null才依赖spring的事件机制完成延迟暴露
        Thread thread = new Thread(new Runnable() {
            public void run() {
                try {
                    Thread.sleep(delay);
                } catch (Throwable e) {
                }
                doExport();
            }
        });
        thread.setDaemon(true);
        thread.setName(&quot;DelayExportServiceThread&quot;);
        thread.start();
    } else {
        doExport();
    }
}
</code></pre><p>一目了然，这个方法主要就是解决了到底暴露不暴露的问题，并且到底是不是延迟暴露的问题。接下来看看<code>doExport</code>方法：</p>
<pre><code>protected synchronized void doExport() {
    if (unexported) {
        throw new IllegalStateException(&quot;Already unexported!&quot;);
    }
    if (exported) {
        return;
    }

    exported = true;    //修改暴露状态

    if (interfaceName == null || interfaceName.length() == 0) {
        throw new IllegalStateException(&quot;&lt;dubbo:service interface=\&quot;\&quot; /&gt; interface not allow null!&quot;);
    }

    checkDefault(); //根据文档中提到的参数优先级，决定最终使用的配置值，在spring的xml解析阶段只是简单解析xml的配置值，在真正使用前，还需要看一下：-D和properties文件

    //下面根据文档中的优先级创建对应的继承链
    if (provider != null) { //todo 这里必然成立吧？
        if (application == null) {
            application = provider.getApplication();
        }
        if (module == null) {
            module = provider.getModule();
        }
        if (registries == null) {
            registries = provider.getRegistries();
        }
        if (monitor == null) {
            monitor = provider.getMonitor();
        }
        if (protocols == null) {
            protocols = provider.getProtocols();
        }
    }
    if (module != null) {
        if (registries == null) {
            registries = module.getRegistries();
        }
        if (monitor == null) {
            monitor = module.getMonitor();
        }
    }
    if (application != null) {
        if (registries == null) {
            registries = application.getRegistries();
        }
        if (monitor == null) {
            monitor = application.getMonitor();
        }
    }

    if (ref instanceof GenericService) {    //泛接口实现方式主要用于服务器端没有API接口及模型类元的情况，参数及返回值中的所有POJO均用Map表示，通常用于框架集成，比如：实现一个通用的远程服务Mock框架，可通过实现GenericService接口处理所有服务请求。
        interfaceClass = GenericService.class;
        if (StringUtils.isEmpty(generic)) {
            generic = Boolean.TRUE.toString();
        }
    } else {
        try {
            interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()
                    .getContextClassLoader());
        } catch (ClassNotFoundException e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
        checkInterfaceAndMethods(interfaceClass, methods);  //检查接口和方法的匹配情况
        checkRef(); //检查接口和实现的匹配情况
        generic = Boolean.FALSE.toString();
    }

    if(local !=null){   //todo 文档中并没有与local相关的参数解释
        if(local==&quot;true&quot;){
            local=interfaceName+&quot;Local&quot;;
        }
        Class&lt;?&gt; localClass;
        try {
            localClass = ClassHelper.forNameWithThreadContextClassLoader(local);
        } catch (ClassNotFoundException e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
        if(!interfaceClass.isAssignableFrom(localClass)){
            throw new IllegalStateException(&quot;The local implemention class &quot; + localClass.getName() + &quot; not implement interface &quot; + interfaceName);
        }
    }

    //本地存根，http://alibaba.github.io/dubbo-doc-static/Stub+Proxy-zh.htm
    if(stub !=null){
        if(stub==&quot;true&quot;){
            stub=interfaceName+&quot;Stub&quot;;  //todo 这里文档中的解释貌似有错误：http://alibaba.github.io/dubbo-doc-static/Service+Config-zh.htm
        }
        Class&lt;?&gt; stubClass;
        try {
            stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);
        } catch (ClassNotFoundException e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
        if(!interfaceClass.isAssignableFrom(stubClass)){
            throw new IllegalStateException(&quot;The stub implemention class &quot; + stubClass.getName() + &quot; not implement interface &quot; + interfaceName);
        }
    }

    //作用雷同于上面的checkDefault()，根据文档中提到的参数优先级来选择使用的配置参数
    checkApplication();
    checkRegistry();
    checkProtocol();
    appendProperties(this);

    checkStubAndMock(interfaceClass);   //检查local，stub和mock的有效性

    if (path == null || path.length() == 0) {   //此时path如果还为空，这使用interfaceName
        path = interfaceName;
    }

    doExportUrls();
}
</code></pre><p>木牛错，<code>doExport</code>方法依然是在做预备工作，感觉越来越靠近真像了，目前为止，我们已经按照规定的优先级最终确定了要暴露成为服务的bean的”大部分”相关配置参数，并校验了相关参数的有效性（例如：ref，method，stub，mock，path等）。再来看一下<code>doExportUrls</code>方法：</p>
<pre><code>private void doExportUrls() {
    List&lt;URL&gt; registryURLs = loadRegistries(true);  //获取所有的注册中心地址
    for (ProtocolConfig protocolConfig : protocols) {
        doExportUrlsFor1Protocol(protocolConfig, registryURLs);
    }
}
</code></pre><p>好，是该真刀真枪干一架的时候了，<code>doExportUrlsFor1Protocol</code>应该就是今次的Boss，解决掉它我们就回家。</p>
<pre><code>private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) {
    String name = protocolConfig.getName();
    if (name == null || name.length() == 0) {
        name = &quot;dubbo&quot;; //N多次的检查，N多次的赋值，这算是严谨呢？还是重复？
    }

    String host = protocolConfig.getHost();
    if (provider != null &amp;&amp; (host == null || host.length() == 0)) {
        host = provider.getHost();
    }
    boolean anyhost = false;
    if (NetUtils.isInvalidLocalHost(host)) {    //检查host是否为本地ip，或者无效的
        anyhost = true;
        try {
            host = InetAddress.getLocalHost().getHostAddress();
        } catch (UnknownHostException e) {
            logger.warn(e.getMessage(), e);
        }
        if (NetUtils.isInvalidLocalHost(host)) {    //如果拿到的还是本地地址，就只能出杀手锏了
            if (registryURLs != null &amp;&amp; registryURLs.size() &gt; 0) {
                for (URL registryURL : registryURLs) {
                    try {
                        Socket socket = new Socket();
                        try {
                            //尝试连接注册中心，选用连接时使用的ip地址
                            SocketAddress addr = new InetSocketAddress(registryURL.getHost(), registryURL.getPort());
                            socket.connect(addr, 1000);
                            host = socket.getLocalAddress().getHostAddress();
                            break;
                        } finally {
                            try {
                                socket.close();
                            } catch (Throwable e) {}
                        }
                    } catch (Exception e) {
                        logger.warn(e.getMessage(), e);
                    }
                }
            }
            if (NetUtils.isInvalidLocalHost(host)) {
                host = NetUtils.getLocalHost(); //实在不行，就只能使用本机上第一个找到的合法ip了
            }
        }
    }

    Integer port = protocolConfig.getPort();
    if (provider != null &amp;&amp; (port == null || port == 0)) {
        port = provider.getPort();
    }
    final int defaultPort = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(name).getDefaultPort();
    if (port == null || port == 0) {
        port = defaultPort;
    }
    if (port == null || port &lt;= 0) {
        port = getRandomPort(name);
        if (port == null || port &lt; 0) {
            port = NetUtils.getAvailablePort(defaultPort);  //到这里如果还没有拿到port，就直接随机拿个能用的端口
            putRandomPort(name, port);  //这一步很讲究，意味着相同协议使用相同的端口，要理解这个就需要先消化dubbo底层通信方式。
        }
        logger.warn(&quot;Use random available port(&quot; + port + &quot;) for protocol &quot; + name);
    }

    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
    if (anyhost) {
        map.put(Constants.ANYHOST_KEY, &quot;true&quot;);
    }
    map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);
    map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());
    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));
    if (ConfigUtils.getPid() &gt; 0) {
        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));
    }

    //获取相关的配置参数用于后面的url生成，注意优先级顺序哟
    appendParameters(map, application);
    appendParameters(map, module);
    appendParameters(map, provider, Constants.DEFAULT_KEY);
    appendParameters(map, protocolConfig);
    appendParameters(map, this);

    if (methods != null &amp;&amp; methods.size() &gt; 0) {
        for (MethodConfig method : methods) {
            appendParameters(map, method, method.getName());

            //处理重试设置
            String retryKey = method.getName() + &quot;.retry&quot;;
            if (map.containsKey(retryKey)) {
                String retryValue = map.remove(retryKey);
                if (&quot;false&quot;.equals(retryValue)) {
                    map.put(method.getName() + &quot;.retries&quot;, &quot;0&quot;);
                }
            }

            List&lt;ArgumentConfig&gt; arguments = method.getArguments();
            if (arguments != null &amp;&amp; arguments.size() &gt; 0) {
                for (ArgumentConfig argument : arguments) { //ArgumentConfig作用主要就是用来完成事件回调机制。
                    //类型自动转换.
                    if(argument.getType() != null &amp;&amp; argument.getType().length() &gt;0){
                        Method[] methods = interfaceClass.getMethods();
                        //遍历所有方法
                        if(methods != null &amp;&amp; methods.length &gt; 0){
                            for (int i = 0; i &lt; methods.length; i++) {
                                String methodName = methods[i].getName();
                                //匹配方法名称，获取方法签名.
                                if(methodName.equals(method.getName())){    //注意方法重载情况
                                    Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();
                                    //一个方法中单个callback
                                    if (argument.getIndex() != -1 ){    //todo 这部分和文档写的有出入，不过这也不是第一次了。。
                                        if (argtypes[argument.getIndex()].getName().equals(argument.getType())){
                                            appendParameters(map, argument, method.getName() + &quot;.&quot; + argument.getIndex());
                                        }else {
                                            throw new IllegalArgumentException(&quot;argument config error : the index attribute and type attirbute not match :index :&quot;+argument.getIndex() + &quot;, type:&quot; + argument.getType());
                                        }
                                    } else {
                                        //一个方法中多个callback
                                        for (int j = 0 ;j&lt;argtypes.length ;j++) {   //todo 这部分和文档写的有出入，不过这也不是第一次了。。
                                            Class&lt;?&gt; argclazz = argtypes[j];
                                            if (argclazz.getName().equals(argument.getType())){
                                                appendParameters(map, argument, method.getName() + &quot;.&quot; + j);
                                                if (argument.getIndex() != -1 &amp;&amp; argument.getIndex() != j){
                                                    throw new IllegalArgumentException(&quot;argument config error : the index attribute and type attirbute not match :index :&quot;+argument.getIndex() + &quot;, type:&quot; + argument.getType());
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }else if(argument.getIndex() != -1){
                        appendParameters(map, argument, method.getName() + &quot;.&quot; + argument.getIndex());
                    }else {
                        throw new IllegalArgumentException(&quot;argument config must set index or type attribute.eg: &lt;dubbo:argument index=&apos;0&apos; .../&gt; or &lt;dubbo:argument type=xxx .../&gt;&quot;);
                    }

                }
            }
        } // end of methods for
    }

    if (ProtocolUtils.isGeneric(generic)) { //处理泛化
        map.put(&quot;generic&quot;, generic);
        map.put(&quot;methods&quot;, Constants.ANY_VALUE);
    } else {
        String revision = Version.getVersion(interfaceClass, version);
        if (revision != null &amp;&amp; revision.length() &gt; 0) {
            map.put(&quot;revision&quot;, revision);  //todo 为什么是revision?
        }

        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames(); //todo 动态封装interfaceClass，目前不知道干啥用，猜测dubbo直接操作的都是这个封装后的wrapper
        if(methods.length == 0) {
            logger.warn(&quot;NO method found in service interface &quot; + interfaceClass.getName());
            map.put(&quot;methods&quot;, Constants.ANY_VALUE);
        }
        else {
            map.put(&quot;methods&quot;, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;));
        }
    }

    //令牌验证，为空表示不开启，如果为true，表示随机生成动态令牌，否则使用静态令牌，令牌的作用是防止消费者绕过注册中心直接访问，保证注册中心的授权功能有效，如果使用点对点调用，需关闭令牌功能
    if (! ConfigUtils.isEmpty(token)) {
        if (ConfigUtils.isDefault(token)) {
            map.put(&quot;token&quot;, UUID.randomUUID().toString());
        } else {
            map.put(&quot;token&quot;, token);
        }
    }

    //injvm表示不会跨进程，所以不需要注册中心
    if (&quot;injvm&quot;.equals(protocolConfig.getName())) {
        protocolConfig.setRegister(false);
        map.put(&quot;notify&quot;, &quot;false&quot;);
    }

    // 导出服务
    String contextPath = protocolConfig.getContextpath();
    if ((contextPath == null || contextPath.length() == 0) &amp;&amp; provider != null) {
        contextPath = provider.getContextpath();
    }
    URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? &quot;&quot; : contextPath + &quot;/&quot;) + path, map);   //拿到服务的url

    if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)
            .hasExtension(url.getProtocol())) {
        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)
                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);
    }

    String scope = url.getParameter(Constants.SCOPE_KEY);
    //配置为none不暴露
    if (! Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) {

        //配置不是remote的情况下做本地暴露 (配置为remote，则表示只暴露远程服务)
        if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) {
            exportLocal(url);
        }
        //如果配置不是local则暴露为远程服务.(配置为local，则表示只暴露远程服务)
        if (! Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope) ){
            if (logger.isInfoEnabled()) {
                logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() + &quot; to url &quot; + url);
            }
            if (registryURLs != null &amp;&amp; registryURLs.size() &gt; 0
                    &amp;&amp; url.getParameter(&quot;register&quot;, true)) {
                for (URL registryURL : registryURLs) {
                    url = url.addParameterIfAbsent(&quot;dynamic&quot;, registryURL.getParameter(&quot;dynamic&quot;));
                    URL monitorUrl = loadMonitor(registryURL);
                    if (monitorUrl != null) {
                        url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());
                    }
                    if (logger.isInfoEnabled()) {
                        logger.info(&quot;Register dubbo service &quot; + interfaceClass.getName() + &quot; url &quot; + url + &quot; to registry &quot; + registryURL);
                    }
                    //todo 暴露为何要封装一层代理呢？
                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));

                    Exporter&lt;?&gt; exporter = protocol.export(invoker);
                    exporters.add(exporter);
                }
            } else {
                //todo 暴露为何要封装一层代理呢？
                Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);

                Exporter&lt;?&gt; exporter = protocol.export(invoker);
                exporters.add(exporter);
            }
        }
    }
    this.urls.add(url);
}
</code></pre><p>一路走来可以发现，dubbo会为每个有效协议暴露一份服务，并且会注册到所有有效的注册中心里。而bean转变为service中最重要的就是映射出来的<code>URL</code>，也就是说我们在配置文件中进行的相关配置都会映射成对应url中的相关部分，举个例子：</p>
<pre><code>&lt;dubbo:application name=&quot;demo-provider&quot; owner=&quot;programmer&quot; organization=&quot;dubbox&quot;/&gt;
&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;/&gt;
&lt;dubbo:protocol name=&quot;dubbo&quot; serialization=&quot;kryo&quot; optimizer=&quot;com.alibaba.dubbo.demo.SerializationOptimizerImpl&quot;/&gt;

&lt;bean id=&quot;bidService&quot; class=&quot;com.alibaba.dubbo.demo.bid.BidServiceImpl&quot; /&gt;
&lt;dubbo:service interface=&quot;com.alibaba.dubbo.demo.bid.BidService&quot; ref=&quot;bidService&quot;  protocol=&quot;dubbo&quot; /&gt;
</code></pre><p>我们通过debug看一下最终它映射出来的url是什么：</p>
<pre><code>//exportLocal
injvm://127.0.0.1/com.alibaba.dubbo.demo.bid.BidService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.bid.BidService&amp;methods=throwNPE,bid&amp;optimizer=com.alibaba.dubbo.demo.SerializationOptimizerImpl&amp;organization=dubbox&amp;owner=programmer&amp;pid=3872&amp;serialization=kryo&amp;side=provider&amp;timestamp=1422241023451

//exportRemote
registry://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.0&amp;export=dubbo%3A%2F%2F192.168.153.1%3A20880%2Fcom.alibaba.dubbo.demo.bid.BidService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.bid.BidService%26methods%3DthrowNPE%2Cbid%26optimizer%3Dcom.alibaba.dubbo.demo.SerializationOptimizerImpl%26organization%3Ddubbox%26owner%3Dprogrammer%26pid%3D3872%26serialization%3Dkryo%26side%3Dprovider%26timestamp%3D1422241023451&amp;organization=dubbox&amp;owner=programmer&amp;pid=3872&amp;registry=zookeeper&amp;timestamp=1422240274186
</code></pre><p>那么这个<code>url</code>的作用是什么呢？官方给出的<a href="http://alibaba.github.io/dubbo-doc-static/Init+Detail-zh.htm" target="_blank" rel="noopener">解释</a>很明确，这个url作为解耦的通信数据（跨层调用的参数），有了它dubbo就可以更容易做到业务逻辑实现的替换。除此之外可以看到url中还包含了大量的辅助参数（例如：timeout，version，organization等）供服务治理使用，这些都是根据真实需求一步一步补充完善的，可见，<strong>好的架构是演化而来的</strong>。</p>
<p>可以看到贴出来的代码中包含很多todo项，其中一些问题我们从代码层面是很难找到答案的，我们需要上升到业务，运维甚至架构师高度才能消化得了，小弟将在后续的分析中慢慢的尝试解开谜团。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:edisondik@gmail.com">kazaff</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://blog.kazaff.me/2015/01/26/dubbo如何一步一步拿到bean/">https://blog.kazaff.me/2015/01/26/dubbo如何一步一步拿到bean/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/spring/">spring</a><a class="post-meta__tags" href="/tags/dubbo/">dubbo</a><a class="post-meta__tags" href="/tags/dubbox/">dubbox</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/weichat.png"><div class="post-qr-code__desc">微信打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/alipay.png"><div class="post-qr-code__desc">支付宝打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2015/01/27/dubbo中服务暴露的细节/"><i class="fa fa-chevron-left">  </i><span>Dubbo的服务暴露细节</span></a></div><div class="next-post pull-right"><a href="/2015/01/26/rsync和inotify配置/"><span>Rsync和inotify配置</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://blog.kazaff.me/2015/01/26/dubbo如何一步一步拿到bean/';
  this.page.identifier = '2015/01/26/dubbo如何一步一步拿到bean/';
  this.page.title = 'Dubbo如何一步一步拿到bean';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'http-blog-kazaff-me' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://http-blog-kazaff-me.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(/img/banner.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2021 By kazaff</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>