<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="［译]全栈Redux实战"><meta name="keywords" content="react,单元测试,Immutable-js,Redux"><meta name="author" content="kazaff,edisondik@gmail.com"><meta name="copyright" content="kazaff"><title>［译]全栈Redux实战 | kazaff's blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '3.9.0'
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#你需要准备什么"><span class="toc-number">1.</span> <span class="toc-text">你需要准备什么</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">kazaff</div><div class="author-info__description text-center">coder,leader,tinker</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">198</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">431</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">20</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/banner.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">kazaff's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">［译]全栈Redux实战</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 10月 8 2015</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/前端/">前端</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2015/10/08/译-全栈Redux实战/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2015/10/08/译-全栈Redux实战/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本文乱译自一篇英文博文（<a href="http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html" target="_blank" rel="noopener">Full-Stack Redux Tutorial</a>），本人英语能力不足，技术能力有限，如有错误，多多包涵。</p>
<a id="more"></a>
<p>#关于Redux+React+Immutable的测试先行开发综合指南</p>
<p>Redux是最近发生在js界令人兴奋的事儿。它把众多优秀的库和框架中非常正确的特性保留了下来：简单且可预测的模型，强调函数式编程和不可变数据，基于api的轻量级实现……你还有什么理由不喜欢呢？</p>
<p>Redux是一个非常小的代码库，掌握它所有的api并不困难，但对很多同学来讲，它要求的：创建组件（blocks），自满足的纯函数和不可变数据会带来不少别扭，那到底应该怎么办呢？</p>
<p>这篇文章将会带你创建一个全栈的Redux和Immutable-js应用。我们将详细讲解创建该应用的Node+Redu后端和React+Redux前端的所有步骤。本指南将使用ES6,Babel,Socket.io,Webpack和Mocha。这是一个非常令人着迷的技术栈选型，你肯定不及待的想要开始了。</p>
<p>##目录<br>（不翻译）</p>
<h2 id="你需要准备什么"><a href="#你需要准备什么" class="headerlink" title="你需要准备什么"></a>你需要准备什么</h2><p>这篇文章需要读者具备开发js应用的能力，我们讲使用Node，ES6，React，Webpack，和Babel，所以你最好能了解这些工具，这样你才不会掉队。</p>
<p>在上面提到的工具集中，你需要安装Node和NPM，和一款你喜欢的编辑器。</p>
<p>##应用</p>
<p>我们将要开发一款应用，它用来为聚会，会议，集会等用户群提供实时投票功能。</p>
<p>这个点子来自于现实中我们经常需要为电影，音乐，编程语言等进行投票。该应用将所有选项两两分组，这样用户可以根据喜好进行二选一，最终拿到最佳结果。</p>
<p>举个例子，这里拿Danny Boyle电影做例子来发起投票：</p>
<p><img src="http://teropa.info/images/vote_logic.png" alt></p>
<p>这个应用有两类独立的界面：用于投票的移动端界面，用于其它功能的浏览器界面。投票结果界面设计成有利于幻灯片或其它更大尺寸的屏幕显示，它用来展示投票的实时结果。</p>
<p><img src="http://teropa.info/images/vote_system.png" alt></p>
<p>##架构</p>
<p>该系统应该有2部分组成：浏览器端我们使用React来提供用户界面，服务端我们使用Node来处理投票逻辑。两端通信我们选择使用WebSockets。</p>
<p>我们将使用Redux来组织前后端的应用代码。我们将使用Immutable数据结构来处理应用的state。</p>
<p>虽然我们的前后端存在许多相似性，例如都使用Redux。但是它们之间并没有什么可复用代码。这更像一个分布式系统，靠传递消息进行通信。</p>
<p>##服务端应用</p>
<p>我们先来实现Node应用，这有助于我们专注于核心业务逻辑，而不是过早的被界面干扰。</p>
<p>实现服务端应用，我们需要先了解Redux和Immutable，并且明白它们如何协作。Redux常常被用在React开发中，但它并不限制于此。我们这里就要学习让Redux如何在其它场景下使用。</p>
<p>我推荐大家跟着我们的指导一起写出一个应用，但你也可以直接从<a href="https://github.com/teropa/redux-voting-server" target="_blank" rel="noopener">github</a>上下载代码。</p>
<p>###设计应用的状态树（State Tree）</p>
<p>设计一个Redux应用往往从思考应用的状态树数据结构开始，它是用来描述你的应用在任何时间点下状态的数据结构。</p>
<p>任何的框架和架构都包含状态。在Ember和Backbone框架里，状态就是模型（Models）。在Anglar中，状态常常用Factories和Services来管理。而在大多数Flux实现中，常常用Stores来负责状态。那Redux又和它们有哪些不同之处呢？</p>
<p>最大的不同之处是，在Redux中，应用的状态是全部存在一个单一的树结构中的。换句话说，应用的所有状态信息都存储在这个包含map和array的数据结构中。</p>
<p>这么做很有意义，我们马上就会感受到。最重要的一点是，这么做迫使你将应用的行为和状态隔离开来。状态就是纯数据，它不包含任何方法或函数。</p>
<p>这么做听起来存在局限，特别是你刚刚从面向对象思想背景下转到Redux。但这确实是一种解放，因为这么做将使你专注于数据自身。如果你花一些时间来设计你的应用状态，其它环节将水到渠成。</p>
<p>这并不是说你总应该一上来就设计你的实体状态树然后再做其它部分。通常你最终会同时考虑应用的所有方面。然而，我发现当你想到一个点子时，在写代码前先思考在不同解决方案下状态树的结构会非常有帮助。</p>
<p>所以，让我们先看看我们的投票应用的状态树应该是什么样的。应用的目标是可以针对多个选项进行投票，那么符合直觉的一种初始化状态应该是包含要被投票的选项集合，我们称之为条目[entries]：</p>
<p><img src="http://teropa.info/images/vote_server_tree_entries.png" alt></p>
<p>当投票开始，还必须定位哪些选项是当前项。所以我们可能还需要一个vote条目，它用来存储当前投票的数据对，投票项应该是来自entries中的：</p>
<p><img src="http://teropa.info/images/vote_server_tree_pair.png" alt></p>
<p>除此之外，投票的计数也应该被保存起来：</p>
<p><img src="http://teropa.info/images/vote_server_tree_tally.png" alt></p>
<p>每次用户进行二选一后，未被选择的那项直接丢弃，被选择的条目重新放回entries的末尾，然后从entries头部选择下一对投票项：</p>
<p><img src="http://teropa.info/images/vote_server_tree_next.png" alt></p>
<p>我们可以想象一下，这么周而复始的投票，最终将会得到一个结果，投票也就结束了：</p>
<p><img src="http://teropa.info/images/vote_server_tree_winner.png" alt></p>
<p>如此设计看起来是合情合理的。针对上面的场景存在很多不同的设计，我们当前的做法也可能不是最佳的，但我们暂时就先这么定吧，足够我们进行下一步了。最重要的是我们在没有写任何代码的前提下已经从最初的点子过渡到确定了应用的具体功能。</p>
<p>###项目安排</p>
<p>是时候开始脏活累活了。开始之前，我们先创建一个项目目录：</p>
<pre><code>mkdir voting-server
cd voting-server
npm init         #所有提示问题直接敲回车即可
</code></pre><p>初始化完毕后，我们的项目目录下将会只存在一个<em>package.json</em>文件。</p>
<p>我们将采用ES6语法来写代码。Node是从4.0.0版本后开始支持大多数ES6语法的，并且目前并不支持modules，但我们需要用到。我们将加入Babel，这样我们就能将ES6直接转换成ES5了：</p>
<pre><code>npm install --save-dev babel
</code></pre><p>我们还需要些库来用于写单元测试：</p>
<pre><code>npm install --save-dev mocha chai
</code></pre><p><a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a>是一个我们将要使用的测试框架，<a href="http://chaijs.com/" target="_blank" rel="noopener">Chai</a>是一个我们用来测试的断言库。</p>
<p>我们将使用下面的mocha命令来跑测试项：</p>
<pre><code>./node_modules/mocha/bin/mocha --compilers js:babel/register --recursive
</code></pre><p>这条命令告诉Mocha递归的去项目中查找并执行所有测试项，但执行前先使用Babel进行语法转换。</p>
<p>为了使用方便，可以在我们的<em>package.json</em>中添加下面这段代码：</p>
<pre><code>&quot;scripts&quot;: {
      &quot;test&quot;: &quot;mocha --compilers js:babel/register --recursive&quot;
},
</code></pre><p>这样以后我们跑测试就只需要执行：</p>
<pre><code>npm run test
</code></pre><p>另外，我们还可以添加<em>test:watch</em>命令，它用来监控文件变化并自动跑测试项：</p>
<pre><code>&quot;scripts&quot;: {
      &quot;test&quot;: &quot;mocha --compilers js:babel/register --recursive&quot;,
      &quot;test:watch&quot;: &quot;npm run test -- --watch&quot;
},
</code></pre><p>我们还将用到一个库，来自于facebook：<a href="http://facebook.github.io/immutable-js/" target="_blank" rel="noopener">Immutable</a>，它提供了许多数据结构供我们使用。下一小节我们再来讨论Immutable，但我们在这里先将它加入到我们的项目中，附带<a href="https://github.com/astorije/chai-immutable" target="_blank" rel="noopener">chai-immutable</a>库，它用来向Chai库加入不可变数据结构比对功能：</p>
<pre><code>npm install --save immutable
npm install --save-dev chai-immutable
</code></pre><p>我们需要在所有测试代码前先加入chai-immutable插件，所以我们来先创建一个测试辅助文件：</p>
<pre><code>//test/test_helper.js

import chai from &apos;chai&apos;;
import chaiImmutable from &apos;chai-immutable&apos;;

chai.use(chaiImmutable);
</code></pre><p>然后我们需要让Mocha在开始跑测试之前先加载这个文件，修改package.json：</p>
<pre><code>&quot;scripts&quot;: {
      &quot;test&quot;: &quot;mocha --compilers js:babel/register --        require ./test/test_helper.js  --recursive&quot;,
      &quot;test:watch&quot;: &quot;npm run test -- --watch&quot;
},
</code></pre><p>好了，准备的差不多了。</p>
<p>###酸爽的Immutable</p>
<p>第二个值得重视的点是，Redux架构下状态并非只是一个普通的tree，而是一棵不可变的tree。</p>
<p>回想一下前面我们设计的状态tree，你可能会觉得可以直接在应用的代码里直接更新tree：修改映射的值，或删除数组元素等。然而，这并不是Redux允许的。</p>
<p>一个Redux应用的状态树是不可变的数据结构。这意味着，一旦你得到了一棵状态树，它就不会在改变了。任何用户行为改变应用状态，你都会获取一棵映射应用改变后新状态的完整状态树。</p>
<p>这说明任何连续的状态（改变前后）都被分别存储在独立的两棵树。你通过调用一个函数来从一种状态转入下一个状态。</p>
<p><img src="http://teropa.info/images/vote_state_succession.png" alt></p>
<p>这么做好在哪呢？第一，用户通常想一个undo功能，当你误操作导致破坏了应用状态后，你往往想退回到应用的历史状态，而单一的状态tree让该需求变得廉价，你只需要简单保存上一个状态tree的数据即可。你也可以序列化tree并存储起来以供将来重放，这对debug很有帮助的。</p>
<p>抛开其它的特性不谈，不可变数据至少会让你的代码变得简单，这非常重要。你可以用纯函数来进行编程：接受参数数据，返回数据，其它啥都不做。这种函数拥有可预见性，你可以多次调用它，只要参数一致，它总返回相同的结果（冪等性）。测试将变的容易，你不需要在测试前创建太多的准备，仅仅是传入参数和返回值。</p>
<p>不可变数据结构是我们创建应用状态的基础，让我们花点时间来写一些测试项来保证它的正常工作。</p>
<p>为了更了解不可变性，我们来看一个十分简单的数据结构：假设我们有一个计数应用，它只包含一个计数器变量，该变量会从0增加到1，增加到2，增加到3，以此类推。</p>
<p>如果用不可变数据来设计这个计数器变量，则每当计数器自增，我们不是去改变变量本身。你可以想象成该计数器变量没有“setters”方法，你不能执行<code>42.setValue(43)</code>。</p>
<p>每当变化发生，我们将获得一个新的变量，它的值是之前的那个变量的值加1等到的。我们可以为此写一个纯函数，它接受一个参数代表当前的状态，并返回一个值表示新的状态。记住，调用它并会修改传入参数的值。这里看一下函数实现和测试代码：</p>
<pre><code>//test/immutable_spec.js

import {expect} from &apos;chai&apos;;

describe(&apos;immutability&apos;, () =&gt; {

      describe(&apos;a number&apos;, () =&gt; {

        function increment(currentState) {
              return currentState + 1;
        }

        it(&apos;is immutable&apos;, () =&gt; {
              let state = 42;
              let nextState = increment(state);

              expect(nextState).to.equal(43);
              expect(state).to.equal(42);
        });

      });
});
</code></pre><p>可以看到当<code>increment</code>调用后<code>state</code>并没有被修改，这是因为<code>Numbers</code>是不可变的。</p>
<p>我们接下来要做的是让各种数据结构都不可变，而不仅仅是一个整数。</p>
<p>利用Immutable提供的<a href="https://facebook.github.io/immutable-js/docs/#/Listf" target="_blank" rel="noopener">Lists</a>，我们可以假设我们的应用拥有一个电影列表的状态，并且有一个操作用来向当前列表中添加新电影，新列表数据是添加前的列表数据和新增的电影条目合并后的结果，注意，添加前的旧列表数据并没有被修改哦：</p>
<pre><code>//test/immutable_spec.json

import {expect} from &apos;chai&apos;;
import {List} from &apos;immutable&apos;;

describe(&apos;immutability&apos;, () =&gt; {

      // ...

      describe(&apos;A List&apos;, () =&gt; {

        function addMovie(currentState, movie) {
              return currentState.push(movie);
        }

        it(&apos;is immutable&apos;, () =&gt; {
              let state = List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;);
              let nextState = addMovie(state, &apos;Sunshine&apos;);

              expect(nextState).to.equal(List.of(
                &apos;Trainspotting&apos;,
                &apos;28 Days Later&apos;,
                &apos;Sunshine&apos;
              ));
              expect(state).to.equal(List.of(
                &apos;Trainspotting&apos;,
                &apos;28 Days Later&apos;
              ));
        });
      });
});
</code></pre><p>如果我们使用的是原生态js数组，那么上面的<code>addMovie</code>函数并不会保证旧的状态不会被修改。这里我们使用的是Immutable List。</p>
<p>真实软件中，一个状态树通常是嵌套了多种数据结构的：list，map以及其它类型的集合。假设状态树是一个包含了<em>movies</em>列表的hash map，添加一个电影意味着我们需要创建一个新的map，并且在新的map的<em>movies</em>元素中添加该新增数据：</p>
<pre><code>//test/immutable_spec.json

import {expect} from &apos;chai&apos;;
import {List, Map} from &apos;immutable&apos;;

describe(&apos;immutability&apos;, () =&gt; {

      // ...

      describe(&apos;a tree&apos;, () =&gt; {

        function addMovie(currentState, movie) {
              return currentState.set(
                &apos;movies&apos;,
                    currentState.get(&apos;movies&apos;).push(movie)
              );
        }

        it(&apos;is immutable&apos;, () =&gt; {
              let state = Map({
                movies: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;)
              });
              let nextState = addMovie(state, &apos;Sunshine&apos;);

              expect(nextState).to.equal(Map({
                movies: List.of(
                      &apos;Trainspotting&apos;,
                      &apos;28 Days Later&apos;,
                      &apos;Sunshine&apos;
                )
              }));
              expect(state).to.equal(Map({
                    movies: List.of(
                      &apos;Trainspotting&apos;,
                      &apos;28 Days Later&apos;
                )
              }));
        });
      });
});
</code></pre><p>该例子和前面的那个类似，主要用来展示在嵌套结构下Immutable的行为。</p>
<p>针对类似上面这个例子的嵌套数据结构，Immutable提供了很多辅助函数，可以帮助我们更容易的定位嵌套数据的内部属性，以达到更新对应值的目的。我们可以使用一个叫<code>update</code>的方法来修改上面的代码：</p>
<pre><code>//test/immutable_spec.json

function addMovie(currentState, movie) {
      return currentState.update(&apos;movies&apos;, movies =&gt; movies.push(movie));
}
</code></pre><p>现在我们很好的了解了不可变数据，这将被用于我们的应用状态。<a href="https://facebook.github.io/immutable-js/docs/#/" target="_blank" rel="noopener">Immutable API</a>提供了非常多的辅助函数，我们目前只是学了点皮毛。</p>
<p>不可变数据是Redux的核心理念，但并不是必须使用Immutable库来实现这个特性。事实上，<a href="http://rackt.github.io/redux/" target="_blank" rel="noopener">官方Redux文档</a>使用的是原生js对象和数组，并通过简单的扩展它们来实现的。</p>
<p>这个教程中，我们将使用Immutable库，原因如下：</p>
<ul>
<li>该库将使得实现不可变数据结构变得非常简单；</li>
<li>我个人偏爱于将尽可能的使用不可变数据，如果你的数据允许直接修改，迟早会有人踩坑；</li>
<li>不可变数据结构更新是持续的，意味着很容易产生性能平静，特别维护是非常庞大的状态树，使用原生js对象和数组意味着要频繁的进行拷贝，很容易导致性能问题。</li>
</ul>
<p>###基于纯函数实现应用逻辑</p>
<p>根据目前我们掌握的不可变状态树和相关操作，我们可以尝试实现投票应用的逻辑。应用的核心逻辑我们拆分成：状态树结构和生成新状态树的函数集合。</p>
<p>####加载条目</p>
<p>首先，之前说到，应用允许“加载”一个用来投票的条目集。我们需要一个<code>setEntries</code>函数，它用来提供应用的初始化状态：</p>
<pre><code>//test/core_spec.js

import {List, Map} from &apos;immutable&apos;;
import {expect} from &apos;chai&apos;;

import {setEntries} from &apos;../src/core&apos;;

describe(&apos;application logic&apos;, () =&gt; {

  describe(&apos;setEntries&apos;, () =&gt; {

    it(&apos;adds the entries to the state&apos;, () =&gt; {
      const state = Map();
      const entries = List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;);
      const nextState = setEntries(state, entries);
      expect(nextState).to.equal(Map({
        entries: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;)
      }));
    });
  });
});
</code></pre><p>我们目前<code>setEntries</code>函数的第一版非常简单：在状态map中创建一个<code>entries</code>键，并设置给定的条目List。</p>
<pre><code>//src/core.js

export function setEntries(state, entries) {
    return state.set(&apos;entries&apos;, entries);
}
</code></pre><p>为了方便起见，我们允许函数第二个参数接受一个原生js数组（或支持iterable的类型），但在状态树中它应该是一个Immutable List：</p>
<pre><code>//test/core_spec.js

it(&apos;converts to immutable&apos;, () =&gt; {
  const state = Map();
  const entries = [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;];
  const nextState = setEntries(state, entries);
  expect(nextState).to.equal(Map({
    entries: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;)
  }));
});
</code></pre><p>为了达到要求，我们需要修改一下代码：</p>
<pre><code>//src/core.js

import {List} from &apos;immutable&apos;;

export function setEntries(state, entries) {
  return state.set(&apos;entries&apos;, List(entries));
}
</code></pre><p>####开始投票</p>
<p>当state加载了条目集合后，我们可以调用一个<code>next</code>函数来开始投票。这表示，我们到了之前设计的状态树的第二阶段。</p>
<p><code>next</code>函数需要在状态树创建中一个投票map，该map有拥有一个<code>pair</code>键，值为投票条目中的前两个元素。<br>这两个元素一旦确定，就要从之前的条目列表中清除：</p>
<pre><code>//test/core_spec.js

import {List, Map} from &apos;immutable&apos;;
import {expect} from &apos;chai&apos;;
import {setEntries, next} from &apos;../src/core&apos;;

describe(&apos;application logic&apos;, () =&gt; {

  // ..

  describe(&apos;next&apos;, () =&gt; {

    it(&apos;takes the next two entries under vote&apos;, () =&gt; {
      const state = Map({
        entries: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;, &apos;Sunshine&apos;)
      });
      const nextState = next(state);
      expect(nextState).to.equal(Map({
        vote: Map({
          pair: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;)
        }),
        entries: List.of(&apos;Sunshine&apos;)
      }));
    });
  });
});
</code></pre><p><code>next</code>函数实现如下：</p>
<pre><code>//src/core.js

import {List, Map} from &apos;immutable&apos;;

// ...

export function next(state) {
  const entries = state.get(&apos;entries&apos;);
  return state.merge({
    vote: Map({pair: entries.take(2)}),
    entries: entries.skip(2)
  });
}
</code></pre><p>####投票</p>
<p>当用户产生投票行为后，每当用户给某个条目投了一票后，<code>vote</code>将会为这个条目添加<code>tally</code>信息，如果对应的<br>条目信息已存在，则需要则增：</p>
<pre><code>//test/core_spec.js

import {List, Map} from &apos;immutable&apos;;
import {expect} from &apos;chai&apos;;
import {setEntries, next, vote} from &apos;../src/core&apos;;

describe(&apos;application logic&apos;, () =&gt; {

  // ...

  describe(&apos;vote&apos;, () =&gt; {

    it(&apos;creates a tally for the voted entry&apos;, () =&gt; {
      const state = Map({
        vote: Map({
          pair: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;)
        }),
        entries: List()
      });
      const nextState = vote(state, &apos;Trainspotting&apos;);
      expect(nextState).to.equal(Map({
        vote: Map({
          pair: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;),
          tally: Map({
            &apos;Trainspotting&apos;: 1
          })
        }),
        entries: List()
      }));
    });

    it(&apos;adds to existing tally for the voted entry&apos;, () =&gt; {
      const state = Map({
        vote: Map({
          pair: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;),
          tally: Map({
            &apos;Trainspotting&apos;: 3,
            &apos;28 Days Later&apos;: 2
          })
        }),
        entries: List()
      });
      const nextState = vote(state, &apos;Trainspotting&apos;);
      expect(nextState).to.equal(Map({
        vote: Map({
          pair: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;),
          tally: Map({
            &apos;Trainspotting&apos;: 4,
            &apos;28 Days Later&apos;: 2
          })
        }),
        entries: List()
      }));
    });
  });
});
</code></pre><p>为了让上面的测试项通过，我们可以如下实现<code>vote</code>函数：</p>
<pre><code>//src/core.js

export function vote(state, entry) {
  return state.updateIn(
    [&apos;vote&apos;, &apos;tally&apos;, entry],
    0,
    tally =&gt; tally + 1
  );
}
</code></pre><p><a href="https://facebook.github.io/immutable-js/docs/#/Map/updateIn" target="_blank" rel="noopener">updateIn</a>让我们更容易完成目标。<br>它接受的第一个参数是个表达式，含义是“定位到嵌套数据结构的指定位置，路径为：[‘vote’, ‘tally’, ‘Trainspotting’]”，<br>并且执行后面逻辑：如果路径指定的位置不存在，则创建新的映射对，并初始化为0，否则对应值加1。</p>
<p>可能对你来说上面的语法太过于晦涩，但一旦你掌握了它，你将会发现用起来非常的酸爽，所以花一些时间学习并<br>适应它是非常值得的。</p>
<p>####继续投票</p>
<p>每次完成一次二选一投票，用户将进入到第二轮投票，每次得票最高的选项将被保存并添加回条目集合。我们需要添加<br>这个逻辑到<code>next</code>函数中：</p>
<pre><code>//test/core_spec.js

describe(&apos;next&apos;, () =&gt; {

  // ...

  it(&apos;puts winner of current vote back to entries&apos;, () =&gt; {
    const state = Map({
      vote: Map({
        pair: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;),
        tally: Map({
          &apos;Trainspotting&apos;: 4,
          &apos;28 Days Later&apos;: 2
        })
      }),
      entries: List.of(&apos;Sunshine&apos;, &apos;Millions&apos;, &apos;127 Hours&apos;)
    });
    const nextState = next(state);
    expect(nextState).to.equal(Map({
      vote: Map({
        pair: List.of(&apos;Sunshine&apos;, &apos;Millions&apos;)
      }),
      entries: List.of(&apos;127 Hours&apos;, &apos;Trainspotting&apos;)
    }));
  });

  it(&apos;puts both from tied vote back to entries&apos;, () =&gt; {
    const state = Map({
      vote: Map({
        pair: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;),
        tally: Map({
          &apos;Trainspotting&apos;: 3,
          &apos;28 Days Later&apos;: 3
        })
      }),
      entries: List.of(&apos;Sunshine&apos;, &apos;Millions&apos;, &apos;127 Hours&apos;)
    });
    const nextState = next(state);
    expect(nextState).to.equal(Map({
      vote: Map({
        pair: List.of(&apos;Sunshine&apos;, &apos;Millions&apos;)
      }),
      entries: List.of(&apos;127 Hours&apos;, &apos;Trainspotting&apos;, &apos;28 Days Later&apos;)
    }));
  });
});
</code></pre><p>我们需要一个<code>getWinners</code>函数来帮我们选择谁是赢家：</p>
<pre><code>//src/core.js

function getWinners(vote) {
  if (!vote) return [];
  const [a, b] = vote.get(&apos;pair&apos;);
  const aVotes = vote.getIn([&apos;tally&apos;, a], 0);
  const bVotes = vote.getIn([&apos;tally&apos;, b], 0);
  if      (aVotes &gt; bVotes)  return [a];
  else if (aVotes &lt; bVotes)  return [b];
  else                       return [a, b];
}

export function next(state) {
  const entries = state.get(&apos;entries&apos;)
                       .concat(getWinners(state.get(&apos;vote&apos;)));
  return state.merge({
    vote: Map({pair: entries.take(2)}),
    entries: entries.skip(2)
  });
}
</code></pre><p>####投票结束</p>
<p>当投票项只剩一个时，投票结束：</p>
<pre><code>//test/core_spec.js

describe(&apos;next&apos;, () =&gt; {

  // ...

  it(&apos;marks winner when just one entry left&apos;, () =&gt; {
    const state = Map({
      vote: Map({
        pair: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;),
        tally: Map({
          &apos;Trainspotting&apos;: 4,
          &apos;28 Days Later&apos;: 2
        })
      }),
      entries: List()
    });
    const nextState = next(state);
    expect(nextState).to.equal(Map({
      winner: &apos;Trainspotting&apos;
    }));
  });
});
</code></pre><p>我们需要在<code>next</code>函数中增加一个条件分支，用来匹配上面的逻辑：</p>
<pre><code>//src/core.js

export function next(state) {
  const entries = state.get(&apos;entries&apos;)
                       .concat(getWinners(state.get(&apos;vote&apos;)));
  if (entries.size === 1) {
    return state.remove(&apos;vote&apos;)
                .remove(&apos;entries&apos;)
                .set(&apos;winner&apos;, entries.first());
  } else {
    return state.merge({
      vote: Map({pair: entries.take(2)}),
      entries: entries.skip(2)
    });
  }
}
</code></pre><p>我们可以直接返回<code>Map({winner: entries.first()})</code>，但我们还是基于旧的状态数据进行一步一步的<br>操作最终得到结果，这么做是为将来做打算。因为应用将来可能还会有很多其它状态数据在Map中，这是一个写测试项的好习惯。<br>所以我们以后要记住，不要重新创建一个状态数据，而是从旧的状态数据中生成新的状态实例。</p>
<p>到此为止我们已经有了一套可以接受的应用核心逻辑实现，表现形式为几个独立的函数。我们也有针对这些函数的<br>测试代码，这些测试项很容易写：No setup, no mocks, no stubs。这就是纯函数的魅力，我们只需要调用它们，<br>并检查返回值就行了。</p>
<p>提醒一下，我们目前还没有安装redux哦，我们就已经可以专注于应用自身的逻辑本身进行实现，而不被所谓的框架<br>所干扰。这真的很不错，对吧？</p>
<p>###初识Actions和Reducers</p>
<p>我们有了应用的核心函数，但在Redux中我们不应该直接调用函数。在这些函数和应用之间还存在这一个中间层：Actions。</p>
<p>Action是一个描述应用状态变化发生的简单数据结构。按照约定，每个action都包含一个<code>type</code>属性，<br>该属性用于描述操作类型。action通常还包含其它属性，下面是一个简单的action例子，该action用来匹配<br>前面我们写的业务操作：</p>
<pre><code>{type: &apos;SET_ENTRIES&apos;, entries: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;]}

{type: &apos;NEXT&apos;}

{type: &apos;VOTE&apos;, entry: &apos;Trainspotting&apos;}
</code></pre><p>actions的描述就这些，但我们还需要一种方式用来把它绑定到我们实际的核心函数上。举个例子：</p>
<pre><code>// 定义一个action
let voteAction = {type: &apos;VOTE&apos;, entry: &apos;Trainspotting&apos;}
// 该action应该触发下面的逻辑
return vote(state, voteAction.entry);
</code></pre><p>我们接下来要用到的是一个普通函数，它用来根据action和当前state来调用指定的核心函数，我们称这种函数叫：<br>reducer：</p>
<pre><code>//src/reducer.js

export default function reducer(state, action) {
  // Figure out which function to call and call it
}
</code></pre><p>我们应该测试这个reducer是否可以正确匹配我们之前的三个actions：</p>
<pre><code>//test/reducer_spec.js

import {Map, fromJS} from &apos;immutable&apos;;
import {expect} from &apos;chai&apos;;

import reducer from &apos;../src/reducer&apos;;

describe(&apos;reducer&apos;, () =&gt; {

  it(&apos;handles SET_ENTRIES&apos;, () =&gt; {
    const initialState = Map();
    const action = {type: &apos;SET_ENTRIES&apos;, entries: [&apos;Trainspotting&apos;]};
    const nextState = reducer(initialState, action);

    expect(nextState).to.equal(fromJS({
      entries: [&apos;Trainspotting&apos;]
    }));
  });

  it(&apos;handles NEXT&apos;, () =&gt; {
    const initialState = fromJS({
      entries: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;]
    });
    const action = {type: &apos;NEXT&apos;};
    const nextState = reducer(initialState, action);

    expect(nextState).to.equal(fromJS({
      vote: {
        pair: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;]
      },
      entries: []
    }));
  });

  it(&apos;handles VOTE&apos;, () =&gt; {
    const initialState = fromJS({
      vote: {
        pair: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;]
      },
      entries: []
    });
    const action = {type: &apos;VOTE&apos;, entry: &apos;Trainspotting&apos;};
    const nextState = reducer(initialState, action);

    expect(nextState).to.equal(fromJS({
      vote: {
        pair: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;],
        tally: {Trainspotting: 1}
      },
      entries: []
    }));
  });
});
</code></pre><p>我们的reducer将根据action的type来选择对应的核心函数，它同时也应该知道如何使用action的额外属性：</p>
<pre><code>//src/reducer.js

import {setEntries, next, vote} from &apos;./core&apos;;

export default function reducer(state, action) {
  switch (action.type) {
  case &apos;SET_ENTRIES&apos;:
    return setEntries(state, action.entries);
  case &apos;NEXT&apos;:
    return next(state);
  case &apos;VOTE&apos;:
    return vote(state, action.entry)
  }
  return state;
}
</code></pre><p>注意，如果reducer没有匹配到action，则应该返回当前的state。</p>
<p>reducers还有一个需要特别注意的地方，那就是当传递一个未定义的state参数时，reducers应该知道如何<br>初始化state为有意义的值。我们的场景中，初始值为Map，因此如果传给reducer一个<code>undefined</code>state的话，<br>reducers将使用一个空的Map来代替：</p>
<pre><code>//test/reducer_spec.js

describe(&apos;reducer&apos;, () =&gt; {

  // ...

  it(&apos;has an initial state&apos;, () =&gt; {
    const action = {type: &apos;SET_ENTRIES&apos;, entries: [&apos;Trainspotting&apos;]};
    const nextState = reducer(undefined, action);
    expect(nextState).to.equal(fromJS({
      entries: [&apos;Trainspotting&apos;]
    }));
  });
});
</code></pre><p>之前在我们的<code>cores.js</code>文件中，我们定义了初始值：</p>
<pre><code>//src/core.js

export const INITIAL_STATE = Map();
</code></pre><p>所以在reducer中我们可以直接导入它：</p>
<pre><code>//src/reducer.js

import {setEntries, next, vote, INITIAL_STATE} from &apos;./core&apos;;

export default function reducer(state = INITIAL_STATE, action) {
  switch (action.type) {
  case &apos;SET_ENTRIES&apos;:
    return setEntries(state, action.entries);
  case &apos;NEXT&apos;:
    return next(state);
  case &apos;VOTE&apos;:
    return vote(state, action.entry)
  }
  return state;
}
</code></pre><p>事实上，提供一个action集合，你可以将它们分解并作用在当前状态上，这也是为什么称它们为reducer的原因：<br>它完全适配reduce方法：</p>
<pre><code>//test/reducer_spec.js

it(&apos;can be used with reduce&apos;, () =&gt; {
  const actions = [
    {type: &apos;SET_ENTRIES&apos;, entries: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;]},
    {type: &apos;NEXT&apos;},
    {type: &apos;VOTE&apos;, entry: &apos;Trainspotting&apos;},
    {type: &apos;VOTE&apos;, entry: &apos;28 Days Later&apos;},
    {type: &apos;VOTE&apos;, entry: &apos;Trainspotting&apos;},
    {type: &apos;NEXT&apos;}
  ];
  const finalState = actions.reduce(reducer, Map());

  expect(finalState).to.equal(fromJS({
    winner: &apos;Trainspotting&apos;
  }));
});
</code></pre><p>相比直接调用核心业务函数，这种批处理或称之为重放一个action集合的能力主要依赖于状态转换的action/reducer模型。<br>举个例子，你可以把actions序列化成json，并轻松的将它发送给Web Worker去执行你的reducer逻辑。或者<br>直接通过网络发送到其它地方供日后执行！</p>
<p>注意我们这里使用的是普通js对象作为actions，而并非不可变数据类型。这是Redux提倡我们的做法。</p>
<p>###尝试Reducer协作</p>
<p>目前我们的核心函数都是接受整个state并返回更新后的整个state。</p>
<p>这么做在大型应用中可能并不太明智。如果你的应用所有操作都要求必须接受完整的state，那么这个项目维护起来就是灾难。<br>日后如果你想进行state结构的调整，你将会付出惨痛的代价。</p>
<p>其实有更好的做法，你只需要保证组件操作尽可能小的state片段即可。我们这里提到的就是模块化思想：<br>提供给模块仅它需要的数据，不多不少。</p>
<p>我们的应用很小，所以这并不是太大的问题，但我们还是选择改善这一点：没有必要给<code>vote</code>函数传递整个state，它只需要<code>vote</code><br>部分。让我们修改一下对应的测试代码：</p>
<pre><code>//test/core_spec.js

describe(&apos;vote&apos;, () =&gt; {

  it(&apos;creates a tally for the voted entry&apos;, () =&gt; {
    const state = Map({
      pair: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;)
    });
    const nextState = vote(state, &apos;Trainspotting&apos;)
    expect(nextState).to.equal(Map({
      pair: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;),
      tally: Map({
        &apos;Trainspotting&apos;: 1
      })
    }));
  });

  it(&apos;adds to existing tally for the voted entry&apos;, () =&gt; {
    const state = Map({
      pair: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;),
      tally: Map({
        &apos;Trainspotting&apos;: 3,
        &apos;28 Days Later&apos;: 2
      })
    });
    const nextState = vote(state, &apos;Trainspotting&apos;);
    expect(nextState).to.equal(Map({
      pair: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;),
      tally: Map({
        &apos;Trainspotting&apos;: 4,
        &apos;28 Days Later&apos;: 2
      })
    }));
  });
});
</code></pre><p>看，测试代码更加简单了。</p>
<p><code>vote</code>函数的实现也需要更新：</p>
<pre><code>//src/core.js

export function vote(voteState, entry) {
  return voteState.updateIn(
    [&apos;tally&apos;, entry],
    0,
    tally =&gt; tally + 1
  );
}
</code></pre><p>最后我们还需要修改<code>reducer</code>，只传递需要的state给<code>vote</code>函数：</p>
<pre><code>//src/reducer.js

export default function reducer(state = INITIAL_STATE, action) {
  switch (action.type) {
  case &apos;SET_ENTRIES&apos;:
    return setEntries(state, action.entries);
  case &apos;NEXT&apos;:
    return next(state);
  case &apos;VOTE&apos;:
    return state.update(&apos;vote&apos;,
                        voteState =&gt; vote(voteState, action.entry));
  }
  return state;
}
</code></pre><p>这个做法在大型项目中非常重要：根reducer只传递部分state给下一级reducer。我们将定位合适的state片段的工作<br>从对应的更新操作中分离出来。</p>
<p><a href="http://rackt.github.io/redux/docs/basics/Reducers.html" target="_blank" rel="noopener">Redux的reducers文档</a>针对这一细节<br>介绍了更多内容，并描述了一些辅助函数的用法，可以在更多长场景中有效的使用。</p>
<p>###初识Redux Store</p>
<p>现在我们可以开始了解如何将上面介绍的内容使用在Redux中了。</p>
<p>如你所见，如果你有一个actions集合，你可以调用<code>reduce</code>，获得最终的应用状态。当然，通常情况下不会如此，actions<br>将会在不同的时间发生：用户操作，远程调用，超时触发器等。</p>
<p>针对这些情况，我们可以使用Redux Store。从名字可以看出它用来存储应用的状态。</p>
<p>Redux Store通常会由一个reducer函数初始化，如我们之前实现的：</p>
<pre><code>import {createStore} from &apos;redux&apos;;

const store = createStore(reducer);
</code></pre><p>接下来你就可以向这个Store指派actions了。Store内部将会使用你实现的reducer来处理action，并负责传递给<br>reducer应用的state，最后负责存储reducer返回的新state：</p>
<pre><code>store.dispatch({type: &apos;NEXT&apos;});
</code></pre><p>任何时刻你都可以通过下面的方法获取当前的state：</p>
<pre><code>store.getState();
</code></pre><p>我们将会创建一个<code>store.js</code>用来初始化和导出一个Redux Store对象。让我们先写测试代码吧：</p>
<pre><code>//test/store_spec.js

import {Map, fromJS} from &apos;immutable&apos;;
import {expect} from &apos;chai&apos;;

import makeStore from &apos;../src/store&apos;;

describe(&apos;store&apos;, () =&gt; {

  it(&apos;is a Redux store configured with the correct reducer&apos;, () =&gt; {
    const store = makeStore();
    expect(store.getState()).to.equal(Map());

    store.dispatch({
      type: &apos;SET_ENTRIES&apos;,
      entries: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;]
    });
    expect(store.getState()).to.equal(fromJS({
      entries: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;]
    }));
  });
});
</code></pre><p>在创建Store之前，我们先在项目中加入Redux库：</p>
<pre><code>npm install --save redux
</code></pre><p>然后我们新建<code>store.js</code>文件，如下：</p>
<pre><code>//src/store.js

import {createStore} from &apos;redux&apos;;
import reducer from &apos;./reducer&apos;;

export default function makeStore() {
  return createStore(reducer);
}
</code></pre><p>Redux Store负责将应用的所有组件关联起来：它持有应用的当前状态，并负责指派actions，且负责调用包含了<br>业务逻辑的reducer。</p>
<p>应用的业务代码和Redux的整合方式非常引人注目，因为我们只有一个普通的reducer函数，这是唯一需要告诉Redux<br>的事儿。其它部分全部都是我们自己的，没有框架入侵的，高便携的纯函数代码！</p>
<p>现在我们创建一个应用的入口文件<code>index.js</code>：</p>
<pre><code>//index.js

import makeStore from &apos;./src/store&apos;;

export const store = makeStore();
</code></pre><p>现在我们可以开启一个<a href="http://segmentfault.com/a/1190000002673137" target="_blank" rel="noopener">Node REPL</a>（例如babel-node）,<br>载入<code>index.js</code>文件来测试执行了。</p>
<p>###配置Socket.io服务</p>
<p>我们的应用服务端用来为一个提供投票和显示结果浏览器端提供服务的，为了这个目的，我们需要考虑两端通信的方式。</p>
<p>这个应用需要实时通信，这确保我们的投票者可以实时查看到所有人的投票信息。为此，我们选择使用WebSockets作为<br>通信方式。因此，我们选择<a href="http://socket.io/" target="_blank" rel="noopener">Socket.io</a>库作为跨终端的websocket抽象实现层，它在客户端<br>不支持websocket的情况下提供了多种备选方案。</p>
<p>让我们在项目中加入Socket.io：</p>
<pre><code>npm install --save socket.io
</code></pre><p>现在，让我新建一个<code>server.js</code>文件：</p>
<pre><code>//src/server.js

import Server from &apos;socket.io&apos;;

export default function startServer() {
const io = new Server().attach(8090);
}
</code></pre><p>这里我们创建了一个Socket.io 服务，绑定8090端口。端口号是我随意选的，你可以更改，但后面客户端连接时<br>要注意匹配。</p>
<p>现在我们可以在<code>index.js</code>中调用这个函数：</p>
<pre><code>//index.js

import makeStore from &apos;./src/store&apos;;
import startServer from &apos;./src/server&apos;;

export const store = makeStore();
startServer();
</code></pre><p>我们现在可以在<code>package.json</code>中添加<code>start</code>指令来方便启动应用：</p>
<pre><code>//package.json
&quot;scripts&quot;: {
    &quot;start&quot;: &quot;babel-node index.js&quot;,
    &quot;test&quot;: &quot;mocha --compilers js:babel/register  --require ./test/test_helper.js  --recursive&quot;,
    &quot;test:watch&quot;: &quot;npm run test --watch&quot;
},
</code></pre><p>这样我们就可以直接执行下面命令来开启应用：</p>
<pre><code>npm run start
</code></pre><p>###用Redux监听器传播State</p>
<p>我们现在拥有了一个Socket.io服务，也建立了Redux状态容器，但它们并没有整合在一起，这就是我们接下来要做的事儿。</p>
<p>我们的服务端需要让客户端知道当前的应用状态（例如：“正在投票的项目是什么？”，“当前的票数是什么？”，<br>“已经出来结果了吗？”）。这些都可以通过每当变化发生时<a href="http://socket.io/docs/server-api/#server#emit" target="_blank" rel="noopener">触发Socket.io事件</a>来实现。</p>
<p>我们如何得知什么时候发生变化？Redux对此提供了方案：你可以订阅Redux Store。这样每当store指派了action之后，在可能发生变化前<br>会调用你提供的指定回调函数。</p>
<p>我们要修改一下<code>startServer</code>实现，我们先来调整一下index.js：</p>
<pre><code>//index.js

import makeStore from &apos;./src/store&apos;;
import {startServer} from &apos;./src/server&apos;;

export const store = makeStore();
startServer(store);
</code></pre><p>接下来我们只需监听store的状态，并把它序列化后用socket.io事件传播给所有处于连接状态的客户端。</p>
<pre><code>//src/server.js

import Server from &apos;socket.io&apos;;

export function startServer(store) {
  const io = new Server().attach(8090);

  store.subscribe(
    () =&gt; io.emit(&apos;state&apos;, store.getState().toJS())
  );
}
</code></pre><p>目前我们的做法是一旦状态有改变，就发送整个state给所有客户端，很容易想到这非常不友好，产生大量流量<br>损耗，更好的做法是只传递改变的state片段，但我们为了简单，在这个例子中就先这么实现吧。</p>
<p>除了状态发生变化时发送状态数据外，每当新客户端连接服务器端时也应该直接发送当前的状态给该客户端。</p>
<p>我们可以通过监听Socket.io的<code>connection</code>事件来实现上述需求：</p>
<pre><code>//src/server.js

import Server from &apos;socket.io&apos;;

export function startServer(store) {
  const io = new Server().attach(8090);

  store.subscribe(
    () =&gt; io.emit(&apos;state&apos;, store.getState().toJS())
  );

  io.on(&apos;connection&apos;, (socket) =&gt; {
    socket.emit(&apos;state&apos;, store.getState().toJS());
  });
}
</code></pre><p>###接受远程调用Redux Actions</p>
<p>除了将应用状态同步给客户端外，我们还需要接受来自客户端的更新操作：投票者需要发起投票，投票组织者需要<br>发起下一轮投票的请求。</p>
<p>我们的解决方案非常简单。我们只需要让客户端发布“action”事件即可，然后我们直接将事件发送给Redux Store：</p>
<pre><code>//src/server.js

import Server from &apos;socket.io&apos;;

export function startServer(store) {
  const io = new Server().attach(8090);

  store.subscribe(
    () =&gt; io.emit(&apos;state&apos;, store.getState().toJS())
  );

  io.on(&apos;connection&apos;, (socket) =&gt; {
    socket.emit(&apos;state&apos;, store.getState().toJS());
    socket.on(&apos;action&apos;, store.dispatch.bind(store));
  });
}
</code></pre><p>这样我们就完成了远程调用actions。Redux架构让我们的项目更加简单：actions仅仅是js对象，可以很容易用于<br>网络传输，我们现在实现了一个支持多人投票的服务端系统，很有成就感吧。</p>
<p>现在我们的服务端操作流程如下：</p>
<ol>
<li>客户端发送一个action给服务端；</li>
<li>服务端交给Redux Store处理action；</li>
<li>Store调用reducer，reducer执行对应的应用逻辑；</li>
<li>Store根据reducer的返回结果来更新状态；</li>
<li>Store触发服务端监听的回调函数；</li>
<li>服务端触发“state”事件；</li>
<li>所有连接的客户端接受到新的状态。</li>
</ol>
<p>在结束服务端开发之前，我们载入一些测试数据来感受一下。我们可以添加<code>entries.json</code>文件：</p>
<pre><code>//entries.json

[
  &quot;Shallow Grave&quot;,
  &quot;Trainspotting&quot;,
  &quot;A Life Less Ordinary&quot;,
  &quot;The Beach&quot;,
  &quot;28 Days Later&quot;,
  &quot;Millions&quot;,
  &quot;Sunshine&quot;,
  &quot;Slumdog Millionaire&quot;,
  &quot;127 Hours&quot;,
  &quot;Trance&quot;,
  &quot;Steve Jobs&quot;
]
</code></pre><p>我们在<code>index.json</code>中加载它然后发起<code>next</code>action来开启投票：</p>
<pre><code>//index.js

import makeStore from &apos;./src/store&apos;;
import {startServer} from &apos;./src/server&apos;;

export const store = makeStore();
startServer(store);

store.dispatch({
  type: &apos;SET_ENTRIES&apos;,
  entries: require(&apos;./entries.json&apos;)
});
store.dispatch({type: &apos;NEXT&apos;});
</code></pre><p>那么接下来我们就来看看如何实现客户端。</p>
<p>##客户端应用</p>
<p>本教程剩余的部分就是写一个React应用，用来连接服务端，并提供投票给使用者。</p>
<p>在客户端我们依然使用Redux。这是更常见的搭配：用于React应用的底层引擎。我们已经了解到Redux如何使用。<br>现在我们将学习它是如何结合并影响React应用的。</p>
<p>我推荐大家跟随本教程的步骤完成应用，但你也可以从<a href="https://github.com/teropa/redux-voting-client" target="_blank" rel="noopener">github</a>上获取源码。</p>
<p>###客户端项目创建</p>
<p>第一件事儿我们当然是创建一个新的NPM项目，如下：</p>
<pre><code>mkdir voting-client
cd voting-client
npm init            # Just hit enter for each question
</code></pre><p>我们的应用需要一个html主页，我们放在<code>dist/index.html</code>：</p>
<pre><code>//dist/index.html

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>这个页面包含一个id为app的<code>&lt;div&gt;</code>，我们将在其中插入我们的应用。在同级目录下还需要一个<code>bundle.js</code>文件。</p>
<p>我们为应用新建第一个js文件，它是系统的入口文件。目前我们先简单的添加一行日志代码：</p>
<pre><code>//src/index.js
console.log(&apos;I am alive!&apos;);
</code></pre><p>为了给我们客户端开发减负，我们将使用<a href="http://webpack.github.io/" target="_blank" rel="noopener">Webpack</a>，让我们加入到项目中：</p>
<pre><code>npm install --save-dev webpack webpack-dev-server
</code></pre><p>接下来，我们在项目根目录新建一个Webpack配置文件：</p>
<pre><code>//webpack.config.js

module.exports = {
  entry: [
    &apos;./src/index.js&apos;
  ],
  output: {
    path: __dirname + &apos;/dist&apos;,
    publicPath: &apos;/&apos;,
    filename: &apos;bundle.js&apos;
  },
  devServer: {
    contentBase: &apos;./dist&apos;
  }
};
</code></pre><p>配置表明将找到我们的<code>index.js</code>入口，并编译到<code>dist/bundle.js</code>中。同时把<code>dist</code>目录当作开发服务器根目录。</p>
<p>你现在可以执行Webpack来生成<code>bundle.js</code>：</p>
<pre><code>webpack
</code></pre><p>你也可以开启一个开发服务器，访问localhost:8080来测试页面效果：</p>
<pre><code>webpack-dev-server
</code></pre><p>由于我们将使用ES6语法和React的<a href="https://facebook.github.io/jsx/" target="_blank" rel="noopener">JSX语法</a>，我们需要一些工具。<br>Babel是一个非常合适的选择，我们需要Babel库：</p>
<pre><code>npm install --save-dev babel-core babel-loader
</code></pre><p>我们可以在Webpack配置文件中添加一些配置，这样webpack将会对<code>.jsx</code>和<code>.js</code>文件使用Babel进行处理：</p>
<pre><code>//webpack.config.js

module.exports = {
    entry: [
        &apos;./src/index.js&apos;
    ],
    module: {
        loaders: [{
            test: /\.jsx?$/,
            exclude: /node_modules/,
            loader: &apos;babel&apos;
        }]
    },
    resolve: {
        extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;]
    },
    output: {
        path: __dirname + &apos;/dist&apos;,
        publicPath: &apos;/&apos;,
        filename: &apos;bundle.js&apos;
    },
    devServer: {
        contentBase: &apos;./dist&apos;
    }
};
</code></pre><p>###单元测试支持</p>
<p>我们也将会为客户端代码编写一些单元测试。我们使用与服务端相同的测试套件：</p>
<pre><code>npm install --save-dev mocha chai
</code></pre><p>我们也将会测试我们的React组件，这就要求需要一个DOM库。我们可能需要像<a href="http://karma-runner.github.io/0.13/index.html" target="_blank" rel="noopener">Karma</a><br>库一样的功能来进行真实web浏览器测试。但我们这里准备使用一个node端纯js的dom库：</p>
<pre><code>npm install --save-dev jsdom@3
</code></pre><p>在用于react之前我们需要一些jsdom的预备代码。我们需要创建通常在浏览器端被提供的<code>document</code>和<code>window</code>对象。<br>并且将它们声明为全局对象，这样才能被React使用。我们可以创建一个测试辅助文件做这些工作：</p>
<pre><code>//test/test_helper.js

import jsdom from &apos;jsdom&apos;;

const doc = jsdom.jsdom(&apos;&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&apos;);
const win = doc.defaultView;

global.document = doc;
global.window = win;
</code></pre><p>此外，我们还需要将jsdom提供的<code>window</code>对象的所有属性导入到Node.js的全局变量中，这样使用这些属性时<br>就不需要<code>window.</code>前缀，这才满足在浏览器环境下的用法：</p>
<pre><code>//test/test_helper.js

import jsdom from &apos;jsdom&apos;;

const doc = jsdom.jsdom(&apos;&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&apos;);
const win = doc.defaultView;

global.document = doc;
global.window = win;

Object.keys(window).forEach((key) =&gt; {
  if (!(key in global)) {
    global[key] = window[key];
  }
});
</code></pre><p>我们还需要使用Immutable集合，所以我们也需要参照后段配置添加相应的库：</p>
<pre><code>npm install --save immutable
npm install --save-dev chai-immutable
</code></pre><p>现在我们再次修改辅助文件：</p>
<pre><code>//test/test_helper.js

import jsdom from &apos;jsdom&apos;;
import chai from &apos;chai&apos;;
import chaiImmutable from &apos;chai-immutable&apos;;

const doc = jsdom.jsdom(&apos;&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&apos;);
const win = doc.defaultView;

global.document = doc;
global.window = win;

Object.keys(window).forEach((key) =&gt; {
  if (!(key in global)) {
    global[key] = window[key];
  }
});

chai.use(chaiImmutable);
</code></pre><p>最后一步是在<code>package.json</code>中添加指令：</p>
<pre><code>//package.json

&quot;scripts&quot;: {
  &quot;test&quot;: &quot;mocha --compilers js:babel-core/register --require ./test/test_helper.js &apos;test/**/*.@(js|jsx)&apos;&quot;
},
</code></pre><p>这几乎和我们在后端做的一样，只有两个地方不同：</p>
<ul>
<li>Babel的编译器名称：在该项目中我们使用<code>babel-core</code>代替<code>babel</code></li>
<li>测试文件设置：服务端我们使用<code>--recursive</code>，但这么设置无法匹配<code>.jsx</code>文件，所以我们需要使用<br><a href="https://github.com/isaacs/node-glob" target="_blank" rel="noopener">glob</a></li>
</ul>
<p>为了实现当代码发生修改后自动进行测试，我们依然添加<code>test:watch</code>指令：</p>
<pre><code>//package.json

&quot;scripts&quot;: {
  &quot;test&quot;: &quot;mocha --compilers js:babel-core/register --require ./test/test_helper.js &apos;test/**/*.@(js|jsx)&apos;&quot;,
  &quot;test:watch&quot;: &quot;npm run test -- --watch&quot;
},
</code></pre><p>###React和react-hot-loader</p>
<p>最后我们来聊聊React！</p>
<p>使用React+Redux+Immutable来开发应用真正酷毙的地方在于：我们可以用纯组件（有时候也称为蠢组件）思想实现<br>任何东西。这个概念与纯函数很类似，有如下一些规则：</p>
<ol>
<li>一个纯组件利用props接受所有它需要的数据，类似一个函数的入参，除此之外它不会被任何其它因素影响；</li>
<li>一个纯组件通常没有内部状态。它用来渲染的数据完全来自于输入props，使用相同的props来渲染相同的纯组件多次，<br>将得到相同的UI。不存在隐藏的内部状态导致渲染不同。</li>
</ol>
<p>这就带来了<a href="https://www.youtube.com/watch?v=1uRC3hmKQnM&amp;feature=youtu.be&amp;t=13m10s" target="_blank" rel="noopener">一个和使用纯函数一样的效果</a>：<br>我们可以根据输入来预测一个组件的渲染，我们不需要知道组件的其它信息。这也使得我们的界面测试变得很简单，<br>与我们测试纯应用逻辑一样简单。</p>
<p>如果组件不包含状态，那么状态放在哪？当然在不可变的Store中啊！我们已经见识过它是怎么运作的了，其<br>最大的特点就是从界面代码中分离出状态。</p>
<p>在此之前，我们还是先给项目添加React：</p>
<pre><code>npm install --save react
</code></pre><p>我们同样需要<a href="https://github.com/gaearon/react-hot-loader" target="_blank" rel="noopener">react-hot-loader</a>。它让我们的开发<br>变得非常快，因为它提供了我们在不丢失当前状态的情况下重载代码的能力：</p>
<pre><code>npm install --save-dev react-hot-loader
</code></pre><p>我们需要更新一下<code>webpack.config.js</code>，使其能热加载：</p>
<pre><code>//webpack.config.js

var webpack = require(&apos;webpack&apos;);

module.exports = {
  entry: [
    &apos;webpack-dev-server/client?http://localhost:8080&apos;,
    &apos;webpack/hot/only-dev-server&apos;,
    &apos;./src/index.js&apos;
  ],
  module: {
    loaders: [{
      test: /\.jsx?$/,
      exclude: /node_modules/,
      loader: &apos;react-hot!babel&apos;
    }],
  }
  resolve: {
    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;]
  },
  output: {
    path: __dirname + &apos;/dist&apos;,
    publicPath: &apos;/&apos;,
    filename: &apos;bundle.js&apos;
  },
  devServer: {
    contentBase: &apos;./dist&apos;,
    hot: true
  },
  plugins: [
    new webpack.HotModuleReplacementPlugin()
  ]
};
</code></pre><p>在上述配置的<code>entry</code>里我们包含了2个新的应用入口点：webpack dev server和webpack hot module loader。<br>它们提供了webpack模块热替换能力。该能力并不是默认加载的，所以上面我们才需要在<code>plugins</code>和<code>devServer</code><br>中手动加载。</p>
<p>配置的<code>loaders</code>部分我们在原先的Babel前配置了<code>react-hot</code>用于<code>.js</code>和<code>.jsx</code>文件。</p>
<p>如果你现在重启开发服务器，你将看到一个在终端看到Hot Module Replacement已开启的消息提醒。我们可以<br>开始写我们的第一个组件了。</p>
<p>###实现投票界面</p>
<p>应用的投票界面非常简单：一旦投票启动，它将现实2个按钮，分别用来表示2个可选项，当投票结束，它显示最终结果。</p>
<p><img src="http://teropa.info/images/voting_shots.png" alt></p>
<p>我们之前都是以测试先行的开发方式，但是在react组件开发中我们将先实现组件，再进行测试。这是因为<br>webpack和react-hot-loader提供了更加优良的<a href="http://blog.iterate.no/2012/10/01/know-your-feedback-loop-why-and-how-to-optimize-it/" target="_blank" rel="noopener">反馈机制</a>。<br>而且，也没有比直接看到界面更加好的测试UI手段了。</p>
<p>让我们假设有一个<code>Voting</code>组件，在之前的入口文件<code>index.html</code>的<code>#app</code>div中加载它。由于我们的代码中<br>包含JSX语法，所以需要把<code>index.js</code>重命名为<code>index.jsx</code>：</p>
<pre><code>//src/index.jsx

import React from &apos;react&apos;;
import Voting from &apos;./components/Voting&apos;;

const pair = [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;];

React.render(
  &lt;Voting pair={pair} /&gt;,
  document.getElementById(&apos;app&apos;)
);
</code></pre><p><code>Voting</code>组件将使用<code>pair</code>属性来加载数据。我们目前可以先硬编码数据，稍后我们将会用真实数据来代替。<br>组件本身是纯粹的，并且对数据来源并不敏感。</p>
<p>注意，在<code>webpack.config.js</code>中的入口点文件名也要修改：</p>
<pre><code>//webpack.config.js

entry: [
  &apos;webpack-dev-server/client?http://localhost:8080&apos;,
  &apos;webpack/hot/only-dev-server&apos;,
  &apos;./src/index.jsx&apos;
],
</code></pre><p>如果你此时重启webpack-dev-server，你将看到缺失Voting组件的报错。让我们修复它：</p>
<pre><code>//src/components/Voting.jsx

import React from &apos;react&apos;;

export default React.createClass({
  getPair: function() {
    return this.props.pair || [];
  },
  render: function() {
    return &lt;div className=&quot;voting&quot;&gt;
      {this.getPair().map(entry =&gt;
        &lt;button key={entry}&gt;
          &lt;h1&gt;{entry}&lt;/h1&gt;
        &lt;/button&gt;
      )}
    &lt;/div&gt;;
  }
});
</code></pre><p>你将会在浏览器上看到组件创建的2个按钮。你可以试试修改代码感受一下浏览器自动更新的魅力，没有刷新，<br>没有页面加载，一切都那么迅雷不及掩耳盗铃。</p>
<p>现在我们来添加第一个单元测试：</p>
<pre><code>//test/components/Voting_spec.jsx

import Voting from &apos;../../src/components/Voting&apos;;

describe(&apos;Voting&apos;, () =&gt; {

});
</code></pre><p>测试组件渲染的按钮，我们必须先看看它的输出是什么。要在单元测试中渲染一个组件，我们需要<code>react/addons</code>提供<br>的辅助函数<a href="https://facebook.github.io/react/docs/test-utils.html#renderintodocument" target="_blank" rel="noopener">renderIntoDocument</a>：</p>
<pre><code>//test/components/Voting_spec.jsx

import React from &apos;react/addons&apos;;
import Voting from &apos;../../src/components/Voting&apos;;

const {renderIntoDocument} = React.addons.TestUtils;

describe(&apos;Voting&apos;, () =&gt; {

  it(&apos;renders a pair of buttons&apos;, () =&gt; {
    const component = renderIntoDocument(
      &lt;Voting pair={[&quot;Trainspotting&quot;, &quot;28 Days Later&quot;]} /&gt;
    );
  });
});
</code></pre><p>一旦组件渲染完毕，我就可以通过react提供的另一个辅助函数<a href="https://facebook.github.io/react/docs/test-utils.html#scryrendereddomcomponentswithtag" target="_blank" rel="noopener">scryRenderedDOMComponentsWithTag</a><br>来拿到<code>button</code>元素。我们期望存在两个按钮，并且期望按钮的值是我们设置的：</p>
<pre><code>//test/components/Voting_spec.jsx

import React from &apos;react/addons&apos;;
import Voting from &apos;../../src/components/Voting&apos;;
import {expect} from &apos;chai&apos;;

const {renderIntoDocument, scryRenderedDOMComponentsWithTag}
  = React.addons.TestUtils;

describe(&apos;Voting&apos;, () =&gt; {

  it(&apos;renders a pair of buttons&apos;, () =&gt; {
    const component = renderIntoDocument(
      &lt;Voting pair={[&quot;Trainspotting&quot;, &quot;28 Days Later&quot;]} /&gt;
    );
    const buttons = scryRenderedDOMComponentsWithTag(component, &apos;button&apos;);

    expect(buttons.length).to.equal(2);
    expect(buttons[0].getDOMNode().textContent).to.equal(&apos;Trainspotting&apos;);
    expect(buttons[1].getDOMNode().textContent).to.equal(&apos;28 Days Later&apos;);
  });
});
</code></pre><p>如果我们跑一下测试，将会看到测试通过的提示：</p>
<pre><code>npm run test
</code></pre><p>当用户点击某个按钮后，组件将会调用回调函数，该函数也由组件的prop传递给组件。</p>
<p>让我们完成这一步，我们可以通过使用React提供的测试工具<a href="https://facebook.github.io/react/docs/test-utils.html#simulate" target="_blank" rel="noopener">Simulate</a><br>来模拟点击操作：</p>
<pre><code>//test/components/Voting_spec.jsx

import React from &apos;react/addons&apos;;
import Voting from &apos;../../src/components/Voting&apos;;
import {expect} from &apos;chai&apos;;

const {renderIntoDocument, scryRenderedDOMComponentsWithTag, Simulate}
  = React.addons.TestUtils;

describe(&apos;Voting&apos;, () =&gt; {

  // ...

  it(&apos;invokes callback when a button is clicked&apos;, () =&gt; {
    let votedWith;
    const vote = (entry) =&gt; votedWith = entry;

    const component = renderIntoDocument(
      &lt;Voting pair={[&quot;Trainspotting&quot;, &quot;28 Days Later&quot;]}
              vote={vote}/&gt;
    );
    const buttons = scryRenderedDOMComponentsWithTag(component, &apos;button&apos;);
    Simulate.click(buttons[0].getDOMNode());

    expect(votedWith).to.equal(&apos;Trainspotting&apos;);
  });
});
</code></pre><p>要想使上面的测试通过很简单，我们只需要让按钮的<code>onClick</code>事件调用<code>vote</code>并传递选中条目即可：</p>
<pre><code>//src/components/Voting.jsx

import React from &apos;react&apos;;

export default React.createClass({
  getPair: function() {
    return this.props.pair || [];
  },
  render: function() {
    return &lt;div className=&quot;voting&quot;&gt;
      {this.getPair().map(entry =&gt;
        &lt;button key={entry}
                onClick={() =&gt; this.props.vote(entry)}&gt;
          &lt;h1&gt;{entry}&lt;/h1&gt;
        &lt;/button&gt;
      )}
    &lt;/div&gt;;
  }
});
</code></pre><p>这就是我们在纯组件中常用的方式：组件不需要做太多，只是回调传入的参数即可。</p>
<p>注意，这里我们又是先写的测试代码，我发现业务代码的测试要比测试UI更容易写，所以后面我们会保持这种<br>方式：UI测试后行，业务代码测试先行。</p>
<p>一旦用户已经针对某对选项投过票了，我们就不应该允许他们再次投票，难道我们应该在组件内部维护某种状态么？<br>不，我们需要保证我们的组件是纯粹的，所以我们需要分离这个逻辑，组件需要一个<code>hasVoted</code>属性，我们先硬编码<br>传递给它：</p>
<pre><code>//src/index.jsx

import React from &apos;react&apos;;
import Voting from &apos;./components/Voting&apos;;

const pair = [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;];

React.render(
  &lt;Voting pair={pair} hasVoted=&quot;Trainspotting&quot; /&gt;,
  document.getElementById(&apos;app&apos;)
);
</code></pre><p>我们可以简单的修改一下组件即可：</p>
<pre><code>//src/components/Voting.jsx

import React from &apos;react&apos;;

export default React.createClass({
  getPair: function() {
    return this.props.pair || [];
  },
  isDisabled: function() {
    return !!this.props.hasVoted;
  },
  render: function() {
    return &lt;div className=&quot;voting&quot;&gt;
      {this.getPair().map(entry =&gt;
        &lt;button key={entry}
                disabled={this.isDisabled()}
                onClick={() =&gt; this.props.vote(entry)}&gt;
          &lt;h1&gt;{entry}&lt;/h1&gt;
        &lt;/button&gt;
      )}
    &lt;/div&gt;;
  }
});
</code></pre><p>让我们再为按钮添加一个提示，当用户投票完毕后，在选中的项目上添加标识，这样用户就更容易理解：</p>
<pre><code>//src/components/Voting.jsx

import React from &apos;react&apos;;

export default React.createClass({
  getPair: function() {
    return this.props.pair || [];
  },
  isDisabled: function() {
    return !!this.props.hasVoted;
  },
  hasVotedFor: function(entry) {
    return this.props.hasVoted === entry;
  },
  render: function() {
    return &lt;div className=&quot;voting&quot;&gt;
      {this.getPair().map(entry =&gt;
        &lt;button key={entry}
                disabled={this.isDisabled()}
                onClick={() =&gt; this.props.vote(entry)}&gt;
          &lt;h1&gt;{entry}&lt;/h1&gt;
          {this.hasVotedFor(entry) ?
            &lt;div className=&quot;label&quot;&gt;Voted&lt;/div&gt; :
            null}
        &lt;/button&gt;
      )}
    &lt;/div&gt;;
  }
});
</code></pre><p>投票界面最后要添加的，就是获胜者样式。我们可能需要添加新的props：</p>
<pre><code>//src/index.jsx

import React from &apos;react&apos;;
import Voting from &apos;./components/Voting&apos;;

const pair = [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;];

React.render(
  &lt;Voting pair={pair} winner=&quot;Trainspotting&quot; /&gt;,
  document.getElementById(&apos;app&apos;)
);
</code></pre><p>我们再次修改一下组件：</p>
<pre><code>//src/components/Voting.jsx

import React from &apos;react&apos;;

export default React.createClass({
  getPair: function() {
    return this.props.pair || [];
  },
  isDisabled: function() {
    return !!this.props.hasVoted;
  },
  hasVotedFor: function(entry) {
    return this.props.hasVoted === entry;
  },
  render: function() {
    return &lt;div className=&quot;voting&quot;&gt;
      {this.props.winner ?
        &lt;div ref=&quot;winner&quot;&gt;Winner is {this.props.winner}!&lt;/div&gt; :
        this.getPair().map(entry =&gt;
          &lt;button key={entry}
                  disabled={this.isDisabled()}
                  onClick={() =&gt; this.props.vote(entry)}&gt;
            &lt;h1&gt;{entry}&lt;/h1&gt;
            {this.hasVotedFor(entry) ?
              &lt;div className=&quot;label&quot;&gt;Voted&lt;/div&gt; :
              null}
          &lt;/button&gt;
        )}
    &lt;/div&gt;;
  }
});
</code></pre><p>目前我们已经完成了所有要做的，但是<code>render</code>函数看着有点丑陋，如果我们可以把胜利界面独立成新的组件<br>可能会好一些：</p>
<pre><code>//src/components/Winner.jsx

import React from &apos;react&apos;;

export default React.createClass({
  render: function() {
    return &lt;div className=&quot;winner&quot;&gt;
      Winner is {this.props.winner}!
    &lt;/div&gt;;
  }
});
</code></pre><p>这样投票组件就会变得很简单，它只需关注投票按钮逻辑即可：</p>
<pre><code>//src/components/Vote.jsx

import React from &apos;react&apos;;

export default React.createClass({
  getPair: function() {
    return this.props.pair || [];
  },
  isDisabled: function() {
    return !!this.props.hasVoted;
  },
  hasVotedFor: function(entry) {
    return this.props.hasVoted === entry;
  },
  render: function() {
    return &lt;div className=&quot;voting&quot;&gt;
      {this.getPair().map(entry =&gt;
        &lt;button key={entry}
                disabled={this.isDisabled()}
                onClick={() =&gt; this.props.vote(entry)}&gt;
          &lt;h1&gt;{entry}&lt;/h1&gt;
          {this.hasVotedFor(entry) ?
            &lt;div className=&quot;label&quot;&gt;Voted&lt;/div&gt; :
            null}
        &lt;/button&gt;
      )}
    &lt;/div&gt;;
  }
});
</code></pre><p>最后我们只需要在<code>Voting</code>组件做一下判断即可：</p>
<pre><code>//src/components/Voting.jsx

import React from &apos;react&apos;;
import Winner from &apos;./Winner&apos;;
import Vote from &apos;./Vote&apos;;

export default React.createClass({
  render: function() {
    return &lt;div&gt;
      {this.props.winner ?
        &lt;Winner ref=&quot;winner&quot; winner={this.props.winner} /&gt; :
        &lt;Vote {...this.props} /&gt;}
    &lt;/div&gt;;
  }
});
</code></pre><p>注意这里我们为胜利组件添加了<a href="https://facebook.github.io/react/docs/more-about-refs.html" target="_blank" rel="noopener">ref</a>，这是因为我们将在单元测试中利用它获取DOM节点。</p>
<p>这就是我们的纯组件！注意目前我们还没有实现任何逻辑：我们并没有定义按钮的点击操作。组件只是用来渲染UI，其它<br>什么都不需要做。后面当我们将UI与Redux Store结合时才会涉及到应用逻辑。</p>
<p>继续下一步之前我们要为刚才新增的特性写更多的单元测试代码。首先，<code>hasVoted</code>属性将会使按钮改变状态：</p>
<pre><code>//test/components/Voting_spec.jsx

it(&apos;disables buttons when user has voted&apos;, () =&gt; {
  const component = renderIntoDocument(
    &lt;Voting pair={[&quot;Trainspotting&quot;, &quot;28 Days Later&quot;]}
            hasVoted=&quot;Trainspotting&quot; /&gt;
  );
  const buttons = scryRenderedDOMComponentsWithTag(component, &apos;button&apos;);

  expect(buttons.length).to.equal(2);
  expect(buttons[0].getDOMNode().hasAttribute(&apos;disabled&apos;)).to.equal(true);
  expect(buttons[1].getDOMNode().hasAttribute(&apos;disabled&apos;)).to.equal(true);
});
</code></pre><p>被<code>hasVoted</code>匹配的按钮将显示<code>Voted</code>标签：</p>
<pre><code>//test/components/Voting_spec.jsx

it(&apos;adds label to the voted entry&apos;, () =&gt; {
  const component = renderIntoDocument(
    &lt;Voting pair={[&quot;Trainspotting&quot;, &quot;28 Days Later&quot;]}
            hasVoted=&quot;Trainspotting&quot; /&gt;
  );
  const buttons = scryRenderedDOMComponentsWithTag(component, &apos;button&apos;);

  expect(buttons[0].getDOMNode().textContent).to.contain(&apos;Voted&apos;);
});
</code></pre><p>当获胜者产生，界面将不存在按钮，取而代替的是胜利者元素：</p>
<pre><code>//test/components/Voting_spec.jsx

it(&apos;renders just the winner when there is one&apos;, () =&gt; {
  const component = renderIntoDocument(
    &lt;Voting winner=&quot;Trainspotting&quot; /&gt;
  );
  const buttons = scryRenderedDOMComponentsWithTag(component, &apos;button&apos;);
  expect(buttons.length).to.equal(0);

  const winner = React.findDOMNode(component.refs.winner);
  expect(winner).to.be.ok;
  expect(winner.textContent).to.contain(&apos;Trainspotting&apos;);
});
</code></pre><p>###不可变数据和纯粹渲染</p>
<p>我们之前已经讨论了许多关于不可变数据的红利，但是，当它和react结合时还会有一个非常屌的好处：<br>如果我们创建纯react组件并传递给它不可变数据作为属性参数，我们将会让react在组件渲染检测中得到最大性能。</p>
<p>这是靠react提供的<a href="https://facebook.github.io/react/docs/pure-render-mixin.html" target="_blank" rel="noopener">PureRenderMixin</a>实现的。<br>当该mixin添加到组件中后，组件的更新检查逻辑将会被改变，由深比对改为高性能的浅比对。</p>
<p>我们之所以可以使用浅比对，就是因为我们使用的是不可变数据。如果一个组件的所有参数都是不可变数据，<br>那么将大大提高应用性能。</p>
<p>我们可以在单元测试里更清楚的看见差别，如果我们向纯组件中传入可变数组，当数组内部元素产生改变后，组件并不会<br>重新渲染：</p>
<pre><code>//test/components/Voting_spec.jsx

it(&apos;renders as a pure component&apos;, () =&gt; {
  const pair = [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;];
  const component = renderIntoDocument(
    &lt;Voting pair={pair} /&gt;
  );

  let firstButton = scryRenderedDOMComponentsWithTag(component, &apos;button&apos;)[0];
  expect(firstButton.getDOMNode().textContent).to.equal(&apos;Trainspotting&apos;);

  pair[0] = &apos;Sunshine&apos;;
  component.setProps({pair: pair});
  firstButton = scryRenderedDOMComponentsWithTag(component, &apos;button&apos;)[0];
  expect(firstButton.getDOMNode().textContent).to.equal(&apos;Trainspotting&apos;);
});
</code></pre><p>如果我们使用不可变数据，则完全没有问题：</p>
<pre><code>//test/components/Voting_spec.jsx

import React from &apos;react/addons&apos;;
import {List} from &apos;immutable&apos;;
import Voting from &apos;../../src/components/Voting&apos;;
import {expect} from &apos;chai&apos;;

const {renderIntoDocument, scryRenderedDOMComponentsWithTag, Simulate}
  = React.addons.TestUtils;

describe(&apos;Voting&apos;, () =&gt; {

  // ...

  it(&apos;does update DOM when prop changes&apos;, () =&gt; {
    const pair = List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;);
    const component = renderIntoDocument(
      &lt;Voting pair={pair} /&gt;
    );

    let firstButton = scryRenderedDOMComponentsWithTag(component, &apos;button&apos;)[0];
    expect(firstButton.getDOMNode().textContent).to.equal(&apos;Trainspotting&apos;);

    const newPair = pair.set(0, &apos;Sunshine&apos;);
    component.setProps({pair: newPair});
    firstButton = scryRenderedDOMComponentsWithTag(component, &apos;button&apos;)[0];
    expect(firstButton.getDOMNode().textContent).to.equal(&apos;Sunshine&apos;);
  });
});
</code></pre><p>如果你跑上面的两个测试，你将会看到非预期的结果：因为实际上UI在两种场景下都更新了。那是因为现在组件<br>依然使用的是深比对，这正是我们使用不可变数据想极力避免的。</p>
<p>下面我们在组件中引入mixin，你就会拿到期望的结果了：</p>
<pre><code>//src/components/Voting.jsx

import React from &apos;react/addons&apos;;
import Winner from &apos;./Winner&apos;;
import Vote from &apos;./Vote&apos;;

export default React.createClass({
  mixins: [React.addons.PureRenderMixin],
  // ...
});



//src/components/Vote.jsx

import React from &apos;react/addons&apos;;

export default React.createClass({
  mixins: [React.addons.PureRenderMixin],
  // ...
});



//src/components/Winner.jsx

import React from &apos;react/addons&apos;;

export default React.createClass({
  mixins: [React.addons.PureRenderMixin],
  // ...
});
</code></pre><p>###投票结果页面和路由实现</p>
<p>投票页面已经搞定了，让我们开始实现投票结果页面吧。</p>
<p>投票结果页面依然会显示两个条目，并且显示它们各自的票数。此外屏幕下方还会有一个按钮，供用户切换到下一轮投票。</p>
<p>现在我们根据什么来确定显示哪个界面呢？使用URL是个不错的主意：我们可以设置根路径<code>#/</code>去显示投票页面，<br>使用<code>#/results</code>来显示投票结果页面。</p>
<p>我们使用<a href="http://rackt.github.io/react-router/" target="_blank" rel="noopener">react-router</a>可以很容易实现这个需求。让我们加入项目：</p>
<pre><code>npm install --save react-router
</code></pre><p>我们这里使用的react-router的0.13版本，它的1.0版本官方还没有发布，如果你打算使用其1.0RC版，那么下面的代码<br>你可能需要做一些修改，可以看<a href="https://github.com/rackt/react-router" target="_blank" rel="noopener">router文档</a>。</p>
<p>我们现在可以来配置一下路由路径，Router提供了一个<code>Route</code>组件用来让我们定义路由信息，同时也提供了<code>DefaultRoute</code><br>组件来让我们定义默认路由：</p>
<pre><code>//src/index.jsx

import React from &apos;react&apos;;
import {Route, DefaultRoute} from &apos;react-router&apos;;
import App from &apos;./components/App&apos;;
import Voting from &apos;./components/Voting&apos;;

const pair = [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;];

const routes = &lt;Route handler={App}&gt;
  &lt;DefaultRoute handler={Voting} /&gt;
&lt;/Route&gt;;

React.render(
  &lt;Voting pair={pair} /&gt;,
  document.getElementById(&apos;app&apos;)
);
</code></pre><p>我们定义了一个默认的路由指向我们的<code>Voting</code>组件。我们需要定义个<code>App</code>组件来用于Route使用。</p>
<p>根路由的作用就是为应用指定一个根组件：通常该组件充当所有子页面的模板。让我们来看看<code>App</code>的细节：</p>
<pre><code>//src/components/App.jsx

import React from &apos;react&apos;;
import {RouteHandler} from &apos;react-router&apos;;
import {List} from &apos;immutable&apos;;

const pair = List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;);

export default React.createClass({
  render: function() {
    return &lt;RouteHandler pair={pair} /&gt;
  }
});
</code></pre><p>这个组件除了渲染了一个<code>RouteHandler</code>组件并没有做别的，这个组件同样是react-router提供的，它的作用就是<br>每当路由匹配了某个定义的页面后将对应的页面组件插入到这个位置。目前我们只定义了一个默认路由指向<code>Voting</code>，<br>所以目前我们的组件总是会显示<code>Voting</code>界面。</p>
<p>注意，我们将我们硬编码的投票数据从<code>index.jsx</code>移到了<code>App.jsx</code>，当你给<code>RouteHandler</code>传递了属性值时，<br>这些参数将会传给当前路由对应的组件。</p>
<p>现在我们可以更新<code>index.jsx</code>：</p>
<pre><code>//src/index.jsx

import React from &apos;react&apos;;
import Router, {Route, DefaultRoute} from &apos;react-router&apos;;
import App from &apos;./components/App&apos;;
import Voting from &apos;./components/Voting&apos;;

const routes = &lt;Route handler={App}&gt;
  &lt;DefaultRoute handler={Voting} /&gt;
&lt;/Route&gt;;

Router.run(routes, (Root) =&gt; {
  React.render(
    &lt;Root /&gt;,
    document.getElementById(&apos;app&apos;)
  );
});
</code></pre><p><code>run</code>方法会根据当前浏览器的路径去查找定义的router来决定渲染哪个组件。一旦确定了对应的组件，它将会被<br>当作指定的<code>Root</code>传给<code>run</code>的回调函数，在回调中我们将使用<code>React.render</code>将其插入DOM中。</p>
<p>目前为止我们已经基于React router实现了之前的内容，我们现在可以很容易添加更多新的路由到应用。让我们<br>把投票结果页面添加进去吧：</p>
<pre><code>//src/index.jsx

import React from &apos;react&apos;;
import Router, {Route, DefaultRoute} from &apos;react-router&apos;;
import App from &apos;./components/App&apos;;
import Voting from &apos;./components/Voting&apos;;
import Results from &apos;./components/Results&apos;;

const routes = &lt;Route handler={App}&gt;
  &lt;Route path=&quot;/results&quot; handler={Results} /&gt;
  &lt;DefaultRoute handler={Voting} /&gt;
&lt;/Route&gt;;

Router.run(routes, (Root) =&gt; {
  React.render(
    &lt;Root /&gt;,
    document.getElementById(&apos;app&apos;)
  );
});
</code></pre><p>这里我们用使用<code>&lt;Route&gt;</code>组件定义了一个名为<code>/results</code>的路径，并绑定<code>Results</code>组件。</p>
<p>让我们简单的实现一下这个<code>Results</code>组件，这样我们就可以看一下路由是如何工作的了：</p>
<pre><code>//src/components/Results.jsx

import React from &apos;react/addons&apos;;

export default React.createClass({
  mixins: [React.addons.PureRenderMixin],
  render: function() {
    return &lt;div&gt;Hello from results!&lt;/div&gt;
  }
});
</code></pre><p>如果你在浏览器中输入<a href="http://localhost:8080/#/results" target="_blank" rel="noopener">http://localhost:8080/#/results</a>，你将会看到该结果组件。<br>而其它路径都对应这投票页面，你也可以使用浏览器的前后按钮来切换这两个界面。</p>
<p>接下来我们来实际实现一下结果组件：</p>
<pre><code>//src/components/Results.jsx

import React from &apos;react/addons&apos;;

export default React.createClass({
  mixins: [React.addons.PureRenderMixin],
  getPair: function() {
    return this.props.pair || [];
  },
  render: function() {
    return &lt;div className=&quot;results&quot;&gt;
      {this.getPair().map(entry =&gt;
        &lt;div key={entry} className=&quot;entry&quot;&gt;
          &lt;h1&gt;{entry}&lt;/h1&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;;
  }
});
</code></pre><p>结果界面除了显示投票项外，还应该显示它们对应的得票数，让我们先硬编码一下：</p>
<pre><code>//src/components/App.jsx

import React from &apos;react/addons&apos;;
import {RouteHandler} from &apos;react-router&apos;;
import {List, Map} from &apos;immutable&apos;;

const pair = List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;);
const tally = Map({&apos;Trainspotting&apos;: 5, &apos;28 Days Later&apos;: 4});

export default React.createClass({
  render: function() {
    return &lt;RouteHandler pair={pair}
                         tally={tally} /&gt;
  }
});
</code></pre><p>现在，我们再来修改一下结果组件：</p>
<pre><code>//src/components/Results.jsx

import React from &apos;react/addons&apos;;

export default React.createClass({
  mixins: [React.addons.PureRenderMixin],
  getPair: function() {
    return this.props.pair || [];
  },
  getVotes: function(entry) {
    if (this.props.tally &amp;&amp; this.props.tally.has(entry)) {
      return this.props.tally.get(entry);
    }
    return 0;
  },
  render: function() {
    return &lt;div className=&quot;results&quot;&gt;
      {this.getPair().map(entry =&gt;
        &lt;div key={entry} className=&quot;entry&quot;&gt;
          &lt;h1&gt;{entry}&lt;/h1&gt;
          &lt;div className=&quot;voteCount&quot;&gt;
            {this.getVotes(entry)}
          &lt;/div&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;;
  }
});
</code></pre><p>现在我们来针对目前的界面功能编写测试代码，以防止未来我们破坏这些功能。</p>
<p>我们期望组件为每个选项都渲染一个div，并在其中显示选项的名称和票数。如果对应的选项没有票数，则默认显示0：</p>
<pre><code>//test/components/Results_spec.jsx

import React from &apos;react/addons&apos;;
import {List, Map} from &apos;immutable&apos;;
import Results from &apos;../../src/components/Results&apos;;
import {expect} from &apos;chai&apos;;

const {renderIntoDocument, scryRenderedDOMComponentsWithClass}
  = React.addons.TestUtils;

describe(&apos;Results&apos;, () =&gt; {

  it(&apos;renders entries with vote counts or zero&apos;, () =&gt; {
    const pair = List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;);
    const tally = Map({&apos;Trainspotting&apos;: 5});
    const component = renderIntoDocument(
      &lt;Results pair={pair} tally={tally} /&gt;
    );
    const entries = scryRenderedDOMComponentsWithClass(component, &apos;entry&apos;);
    const [train, days] = entries.map(e =&gt; e.getDOMNode().textContent);

    expect(entries.length).to.equal(2);
    expect(train).to.contain(&apos;Trainspotting&apos;);
    expect(train).to.contain(&apos;5&apos;);
    expect(days).to.contain(&apos;28 Days Later&apos;);
    expect(days).to.contain(&apos;0&apos;);
  });
});
</code></pre><p>接下来，我们看一下”Next”按钮，它允许用户切换到下一轮投票。</p>
<p>我们的组件应该包含一个回调函数属性参数，当组件中的”Next”按钮被点击后，该回调函数将会被调用。我们来写一下<br>这个操作的测试代码：</p>
<pre><code>//test/components/Results_spec.jsx

import React from &apos;react/addons&apos;;
import {List, Map} from &apos;immutable&apos;;
import Results from &apos;../../src/components/Results&apos;;
import {expect} from &apos;chai&apos;;

const {renderIntoDocument, scryRenderedDOMComponentsWithClass, Simulate}
  = React.addons.TestUtils;

describe(&apos;Results&apos;, () =&gt; {

  // ...

  it(&apos;invokes the next callback when next button is clicked&apos;, () =&gt; {
    let nextInvoked = false;
    const next = () =&gt; nextInvoked = true;

    const pair = List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;);
    const component = renderIntoDocument(
      &lt;Results pair={pair}
               tally={Map()}
               next={next}/&gt;
    );
    Simulate.click(React.findDOMNode(component.refs.next));

    expect(nextInvoked).to.equal(true);
  });
});
</code></pre><p>写法和之前的投票按钮很类似吧。接下来让我们更新一下结果组件：</p>
<pre><code>//src/components/Results.jsx

import React from &apos;react/addons&apos;;

export default React.createClass({
  mixins: [React.addons.PureRenderMixin],
  getPair: function() {
    return this.props.pair || [];
  },
  getVotes: function(entry) {
    if (this.props.tally &amp;&amp; this.props.tally.has(entry)) {
      return this.props.tally.get(entry);
    }
    return 0;
  },
  render: function() {
    return &lt;div className=&quot;results&quot;&gt;
      &lt;div className=&quot;tally&quot;&gt;
        {this.getPair().map(entry =&gt;
          &lt;div key={entry} className=&quot;entry&quot;&gt;
            &lt;h1&gt;{entry}&lt;/h1&gt;
            &lt;div class=&quot;voteCount&quot;&gt;
              {this.getVotes(entry)}
            &lt;/div&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;
      &lt;div className=&quot;management&quot;&gt;
        &lt;button ref=&quot;next&quot;
                className=&quot;next&quot;
                onClick={this.props.next}&gt;
          Next
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;;
  }
});
</code></pre><p>最终投票结束，结果页面和投票页面一样，都要显示胜利者：</p>
<pre><code>//test/components/Results_spec.jsx

it(&apos;renders the winner when there is one&apos;, () =&gt; {
  const component = renderIntoDocument(
    &lt;Results winner=&quot;Trainspotting&quot;
             pair={[&quot;Trainspotting&quot;, &quot;28 Days Later&quot;]}
             tally={Map()} /&gt;
  );
  const winner = React.findDOMNode(component.refs.winner);
  expect(winner).to.be.ok;
  expect(winner.textContent).to.contain(&apos;Trainspotting&apos;);
});
</code></pre><p>我们可以想在投票界面中那样简单的实现一下上面的逻辑：</p>
<pre><code>//src/components/Results.jsx

import React from &apos;react/addons&apos;;
import Winner from &apos;./Winner&apos;;

export default React.createClass({
  mixins: [React.addons.PureRenderMixin],
  getPair: function() {
    return this.props.pair || [];
  },
  getVotes: function(entry) {
    if (this.props.tally &amp;&amp; this.props.tally.has(entry)) {
      return this.props.tally.get(entry);
    }
    return 0;
  },
  render: function() {
    return this.props.winner ?
      &lt;Winner ref=&quot;winner&quot; winner={this.props.winner} /&gt; :
      &lt;div className=&quot;results&quot;&gt;
        &lt;div className=&quot;tally&quot;&gt;
          {this.getPair().map(entry =&gt;
            &lt;div key={entry} className=&quot;entry&quot;&gt;
              &lt;h1&gt;{entry}&lt;/h1&gt;
              &lt;div className=&quot;voteCount&quot;&gt;
                {this.getVotes(entry)}
              &lt;/div&gt;
            &lt;/div&gt;
          )}
        &lt;/div&gt;
        &lt;div className=&quot;management&quot;&gt;
          &lt;button ref=&quot;next&quot;
                   className=&quot;next&quot;
                   onClick={this.props.next}&gt;
            Next
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;;
  }
});
</code></pre><p>到目前为止，我们已经实现了应用的UI，虽然现在它们并没有和真实数据和操作整合起来。这很不错不是么？<br>我们只需要一些占位符数据就可以完成界面的开发，这让我们在这个阶段更专注于UI。</p>
<p>接下来我们将会使用Redux Store来将真实数据整合到我们的界面中。</p>
<p>###初识客户端的Redux Store</p>
<p>Redux将会充当我们UI界面的状态容器，我们已经在服务端用过Redux，之前说的很多内容在这里也受用。<br>现在我们已经准备好要在React应用中使用Redux了，这也是Redux更常见的使用场景。</p>
<p>和在服务端一样，我们先来思考一下应用的状态。客户端的状态和服务端会非常的类似。</p>
<p>我们有两个界面，并在其中需要显示成对的用于投票的条目：</p>
<p><img src="http://teropa.info/images/vote_client_pair.png" alt></p>
<p>此外，结果页面需要显示票数：</p>
<p><img src="http://teropa.info/images/vote_client_tally.png" alt></p>
<p>投票组件还需要记录当前用户已经投票过的选项：</p>
<p><img src="http://teropa.info/images/vote_client_hasvoted.png" alt></p>
<p>结果组件还需要记录胜利者：</p>
<p><img src="http://teropa.info/images/vote_server_tree_winner.png" alt></p>
<p>注意这里除了<code>hasVoted</code>外，其它都映射着服务端状态的子集。</p>
<p>接下来我们来思考一下应用的核心逻辑，actions和reducers应该是什么样的。</p>
<p>我们先来想想能够导致应用状态改变的操作都有那些？状态改变的来源之一是用户行为。我们的UI中存在两种<br>可能的用户操作行为：</p>
<ul>
<li>用户在投票页面点击某个投票按钮；</li>
<li>用户点击下一步按钮。</li>
</ul>
<p>另外，我们知道我们的服务端会将应用当前状态发送给客户端，我们将编写代码来接受状态数据，这也是导致状态<br>改变的来源之一。</p>
<p>我们可以从服务端状态更新开始，之前我们在服务端设置发送了一个<code>state</code>事件。该事件将携带我们之前设计的客户端<br>状态树的状态数据。我们的客户端reducer将通过一个action来将服务器端的状态数据合并到客户端状态树中，<br>这个action如下：</p>
<pre><code>{
  type: &apos;SET_STATE&apos;,
  state: {
    vote: {...}
  }
}
</code></pre><p>让我们先写一下reducer测试代码，它应该接受上面定义的那种action，并合并数据到客户端的当前状态中：</p>
<pre><code>//test/reducer_spec.js

import {List, Map, fromJS} from &apos;immutable&apos;;
import {expect} from &apos;chai&apos;;

import reducer from &apos;../src/reducer&apos;;

describe(&apos;reducer&apos;, () =&gt; {

  it(&apos;handles SET_STATE&apos;, () =&gt; {
    const initialState = Map();
    const action = {
      type: &apos;SET_STATE&apos;,
      state: Map({
        vote: Map({
          pair: List.of(&apos;Trainspotting&apos;, &apos;28 Days Later&apos;),
          tally: Map({Trainspotting: 1})
        })
      })
    };
    const nextState = reducer(initialState, action);

    expect(nextState).to.equal(fromJS({
      vote: {
        pair: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;],
        tally: {Trainspotting: 1}
      }
    }));
  });
});
</code></pre><p>这个renducers接受一个来自socket发送的原始的js数据结构，这里注意不是不可变数据类型哦。我们需要在返回前将其<br>转换成不可变数据类型：</p>
<pre><code>//test/reducer_spec.js

it(&apos;handles SET_STATE with plain JS payload&apos;, () =&gt; {
  const initialState = Map();
  const action = {
    type: &apos;SET_STATE&apos;,
    state: {
      vote: {
        pair: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;],
        tally: {Trainspotting: 1}
      }
    }
  };
  const nextState = reducer(initialState, action);

  expect(nextState).to.equal(fromJS({
    vote: {
      pair: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;],
      tally: {Trainspotting: 1}
    }
  }));
});
</code></pre><p>reducer同样应该可以正确的处理<code>undefined</code>初始化状态：</p>
<pre><code>//test/reducer_spec.js

it(&apos;handles SET_STATE without initial state&apos;, () =&gt; {
  const action = {
    type: &apos;SET_STATE&apos;,
    state: {
      vote: {
        pair: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;],
        tally: {Trainspotting: 1}
      }
    }
  };
  const nextState = reducer(undefined, action);

  expect(nextState).to.equal(fromJS({
    vote: {
      pair: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;],
      tally: {Trainspotting: 1}
    }
  }));
});
</code></pre><p>现在我们来看一下如何实现满足上面测试条件的reducer：</p>
<pre><code>//src/reducer.js

import {Map} from &apos;immutable&apos;;

export default function(state = Map(), action) {

  return state;
}
</code></pre><p>reducer需要处理<code>SET_STATE</code>动作。在这个动作的处理中，我们应该将传入的状态数据和现有的进行合并，<br>使用Map提供的<a href="https://facebook.github.io/immutable-js/docs/#/Map/merge" target="_blank" rel="noopener">merge</a>将很容易来实现这个操作：</p>
<pre><code>//src/reducer.js

import {Map} from &apos;immutable&apos;;

function setState(state, newState) {
  return state.merge(newState);
}

export default function(state = Map(), action) {
  switch (action.type) {
  case &apos;SET_STATE&apos;:
    return setState(state, action.state);
  }
  return state;
}
</code></pre><p>注意这里我们并没有单独写一个核心模块，而是直接在reducer中添加了个简单的<code>setState</code>函数来做业务逻辑。<br>这是因为现在这个逻辑还很简单～</p>
<p>关于改变用户状态的那两个用户交互：投票和下一步，它们都需要和服务端进行通信，我们一会再说。我们现在先把<br>redux添加到项目中：</p>
<pre><code>npm install --save redux
</code></pre><p><code>index.jsx</code>入口文件是一个初始化Store的好地方，让我们暂时先使用硬编码的数据来做：</p>
<pre><code>//src/index.jsx

import React from &apos;react&apos;;
import Router, {Route, DefaultRoute} from &apos;react-router&apos;;
import {createStore} from &apos;redux&apos;;
import reducer from &apos;./reducer&apos;;
import App from &apos;./components/App&apos;;
import Voting from &apos;./components/Voting&apos;;
import Results from &apos;./components/Results&apos;;

const store = createStore(reducer);
store.dispatch({
  type: &apos;SET_STATE&apos;,
  state: {
    vote: {
      pair: [&apos;Sunshine&apos;, &apos;28 Days Later&apos;],
      tally: {Sunshine: 2}
    }
  }
});

const routes = &lt;Route handler={App}&gt;
  &lt;Route path=&quot;/results&quot; handler={Results} /&gt;
  &lt;DefaultRoute handler={Voting} /&gt;
&lt;/Route&gt;;

Router.run(routes, (Root) =&gt; {
  React.render(
    &lt;Root /&gt;,
    document.getElementById(&apos;app&apos;)
  );
});
</code></pre><p>那么，我们如何在react组件中从Store中获取数据呢？</p>
<p>###让React从Redux中获取数据</p>
<p>我们已经创建了一个使用不可变数据类型保存应用状态的Redux Store。我们还拥有接受不可变数据为参数的<br>无状态的纯React组件。如果我们能使这些组件从Store中获取最新的状态数据，那真是极好的。当状态变化时，<br>React会重新渲染组件，pure render mixin可以使得我们的UI避免不必要的重复渲染。</p>
<p>相比我们自己手动实现同步代码，我们更推荐使用[react-redux][<a href="https://github.com/rackt/react-redux]包来做：" target="_blank" rel="noopener">https://github.com/rackt/react-redux]包来做：</a></p>
<pre><code>npm install --save react-redux
</code></pre><p>这个库主要做的是：</p>
<ol>
<li>映射Store的状态到组件的输入props中；</li>
<li>映射actions到组件的回调props中。</li>
</ol>
<p>为了让它可以正常工作，我们需要将顶层的应用组件嵌套在react-redux的<a href="https://github.com/rackt/react-redux#provider-store" target="_blank" rel="noopener">Provider</a>组件中。<br>这将把Redux Store和我们的状态树连接起来。</p>
<p>我们将让Provider包含路由的根组件，这样会使得Provider成为整个应用组件的根节点：</p>
<pre><code>//src/index.jsx

import React from &apos;react&apos;;
import Router, {Route, DefaultRoute} from &apos;react-router&apos;;
import {createStore} from &apos;redux&apos;;
import {Provider} from &apos;react-redux&apos;;
import reducer from &apos;./reducer&apos;;
import App from &apos;./components/App&apos;;
import {VotingContainer} from &apos;./components/Voting&apos;;
import Results from &apos;./components/Results&apos;;

const store = createStore(reducer);
store.dispatch({
  type: &apos;SET_STATE&apos;,
  state: {
    vote: {
      pair: [&apos;Sunshine&apos;, &apos;28 Days Later&apos;],
      tally: {Sunshine: 2}
    }
  }
});

const routes = &lt;Route handler={App}&gt;
  &lt;Route path=&quot;/results&quot; handler={Results} /&gt;
  &lt;DefaultRoute handler={VotingContainer} /&gt;
&lt;/Route&gt;;

Router.run(routes, (Root) =&gt; {
  React.render(
    &lt;Provider store={store}&gt;
      {() =&gt; &lt;Root /&gt;}
    &lt;/Provider&gt;,
    document.getElementById(&apos;app&apos;)
  );
});
</code></pre><p>接下来我们要考虑一下，我们的那些组件需要绑定到Store上。我们一共有5个组件，可以分成三类：</p>
<ul>
<li>根组件<code>App</code>不需要绑定任何数据；</li>
<li><code>Vote</code>和<code>Winner</code>组件只使用父组件传递来的数据，所以它们也不需要绑定；</li>
<li>剩下的组件（<code>Voting</code>和<code>Results</code>）目前都是使用的硬编码数据，我们现在需要将其绑定到Store上。</li>
</ul>
<p>让我们从<code>Voting</code>组件开始。使用react-redux我们得到一个叫<a href="https://github.com/rackt/react-redux#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" target="_blank" rel="noopener">connect</a>的函数：</p>
<pre><code>connect(mapStateToProps)(SomeComponent);
</code></pre><p>该函数的作用就是将Redux Store中的状态数据映射到props对象中。这个props对象将会用于连接到的组件中。<br>在我们的<code>Voting</code>场景中，我们需要从状态中拿到<code>pair</code>和<code>winner</code>值：</p>
<pre><code>//src/components/Voting.jsx

import React from &apos;react/addons&apos;;
import {connect} from &apos;react-redux&apos;;
import Winner from &apos;./Winner&apos;;
import Vote from &apos;./Vote&apos;;

const Voting = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  render: function() {
    return &lt;div&gt;
      {this.props.winner ?
        &lt;Winner ref=&quot;winner&quot; winner={this.props.winner} /&gt; :
        &lt;Vote {...this.props} /&gt;}
    &lt;/div&gt;;
  }
});

function mapStateToProps(state) {
  return {
    pair: state.getIn([&apos;vote&apos;, &apos;pair&apos;]),
    winner: state.get(&apos;winner&apos;)
  };
}

connect(mapStateToProps)(Voting);

export default Voting;
</code></pre><p>在上面的代码中，<code>connect</code>函数并没有修改<code>Voting</code>组件本身，<code>Voting</code>组件依然保持这纯粹性。而<code>connect</code><br>返回的是一个<code>Voting</code>组件的连接版，我们称之为<code>VotingContainer</code>：</p>
<pre><code>//src/components/Voting.jsx

import React from &apos;react/addons&apos;;
import {connect} from &apos;react-redux&apos;;
import Winner from &apos;./Winner&apos;;
import Vote from &apos;./Vote&apos;;

export const Voting = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  render: function() {
    return &lt;div&gt;
      {this.props.winner ?
        &lt;Winner ref=&quot;winner&quot; winner={this.props.winner} /&gt; :
        &lt;Vote {...this.props} /&gt;}
    &lt;/div&gt;;
  }
});

function mapStateToProps(state) {
  return {
    pair: state.getIn([&apos;vote&apos;, &apos;pair&apos;]),
    winner: state.get(&apos;winner&apos;)
  };
}

export const VotingContainer = connect(mapStateToProps)(Voting);
</code></pre><p>这样，这个模块现在导出两个组件：一个纯<code>Voting</code>组件，一个连接后的<code>VotingContainer</code>版本。<br>react-redux官方称前者为“蠢”组件，后者则称为”智能”组件。我更倾向于用“pure”和“connected”来描述它们。<br>怎么称呼随你便，主要是明白它们之间的差别：</p>
<ul>
<li>纯组件完全靠给它传入的props来工作，这非常类似一个纯函数；</li>
<li>连接组件则封装了纯组件和一些逻辑用来与Redux Store协同工作，这些特性是redux-react提供的。</li>
</ul>
<p>我们得更新一下路由表，改用<code>VotingContainer</code>。一旦修改完毕，我们的投票界面将会使用来自Redux Store的数据：</p>
<pre><code>//src/index.jsx

import React from &apos;react&apos;;
import Router, {Route, DefaultRoute} from &apos;react-router&apos;;
import {createStore} from &apos;redux&apos;;
import {Provider} from &apos;react-redux&apos;;
import reducer from &apos;./reducer&apos;;
import App from &apos;./components/App&apos;;
import {VotingContainer} from &apos;./components/Voting&apos;;
import Results from &apos;./components/Results&apos;;

const store = createStore(reducer);
store.dispatch({
  type: &apos;SET_STATE&apos;,
  state: {
    vote: {
      pair: [&apos;Sunshine&apos;, &apos;28 Days Later&apos;],
      tally: {Sunshine: 2}
    }
  }
});

const routes = &lt;Route handler={App}&gt;
  &lt;Route path=&quot;/results&quot; handler={Results} /&gt;
  &lt;DefaultRoute handler={VotingContainer} /&gt;
&lt;/Route&gt;;

Router.run(routes, (Root) =&gt; {
  React.render(
    &lt;Provider store={store}&gt;
      {() =&gt; &lt;Root /&gt;}
    &lt;/Provider&gt;,
    document.getElementById(&apos;app&apos;)
  );
});
</code></pre><p>而在对应的测试代码中，我们则需要使用纯<code>Voting</code>组件定义：</p>
<pre><code>//test/components/Voting_spec.jsx

import React from &apos;react/addons&apos;;
import {List} from &apos;immutable&apos;;
import {Voting} from &apos;../../src/components/Voting&apos;;
import {expect} from &apos;chai&apos;;
</code></pre><p>其它地方不需要修改了。</p>
<p>现在我们来如法炮制投票结果页面：</p>
<pre><code>//src/components/Results.jsx

import React from &apos;react/addons&apos;;
import {connect} from &apos;react-redux&apos;;
import Winner from &apos;./Winner&apos;;

export const Results = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  getPair: function() {
    return this.props.pair || [];
  },
  getVotes: function(entry) {
    if (this.props.tally &amp;&amp; this.props.tally.has(entry)) {
      return this.props.tally.get(entry);
    }
    return 0;
  },
  render: function() {
    return this.props.winner ?
      &lt;Winner ref=&quot;winner&quot; winner={this.props.winner} /&gt; :
      &lt;div className=&quot;results&quot;&gt;
        &lt;div className=&quot;tally&quot;&gt;
          {this.getPair().map(entry =&gt;
            &lt;div key={entry} className=&quot;entry&quot;&gt;
              &lt;h1&gt;{entry}&lt;/h1&gt;
              &lt;div className=&quot;voteCount&quot;&gt;
                {this.getVotes(entry)}
              &lt;/div&gt;
            &lt;/div&gt;
          )}
        &lt;/div&gt;
        &lt;div className=&quot;management&quot;&gt;
          &lt;button ref=&quot;next&quot;
                   className=&quot;next&quot;
                   onClick={this.props.next}&gt;
            Next
          &lt;/button&gt;
      &lt;/div&gt;
      &lt;/div&gt;;
  }
});

function mapStateToProps(state) {
  return {
    pair: state.getIn([&apos;vote&apos;, &apos;pair&apos;]),
    tally: state.getIn([&apos;vote&apos;, &apos;tally&apos;]),
    winner: state.get(&apos;winner&apos;)
  }
}

export const ResultsContainer = connect(mapStateToProps)(Results);
</code></pre><p>同样我们需要修改<code>index.jsx</code>来使用新的<code>ResultsContainer</code>：</p>
<pre><code>//src/index.jsx

import React from &apos;react&apos;;
import Router, {Route, DefaultRoute} from &apos;react-router&apos;;
import {createStore} from &apos;redux&apos;;
import {Provider} from &apos;react-redux&apos;;
import reducer from &apos;./reducer&apos;;
import App from &apos;./components/App&apos;;
import {VotingContainer} from &apos;./components/Voting&apos;;
import {ResultsContainer} from &apos;./components/Results&apos;;

const store = createStore(reducer);
store.dispatch({
  type: &apos;SET_STATE&apos;,
  state: {
    vote: {
      pair: [&apos;Sunshine&apos;, &apos;28 Days Later&apos;],
      tally: {Sunshine: 2}
    }
  }
});

const routes = &lt;Route handler={App}&gt;
  &lt;Route path=&quot;/results&quot; handler={ResultsContainer} /&gt;
  &lt;DefaultRoute handler={VotingContainer} /&gt;
&lt;/Route&gt;;

Router.run(routes, (Root) =&gt; {
  React.render(
    &lt;Provider store={store}&gt;
      {() =&gt; &lt;Root /&gt;}
    &lt;/Provider&gt;,
    document.getElementById(&apos;app&apos;)
  );
});
</code></pre><p>不要忘记修改测试代码啊：</p>
<pre><code>//test/components/Results_spec.jsx

import React from &apos;react/addons&apos;;
import {List, Map} from &apos;immutable&apos;;
import {Results} from &apos;../../src/components/Results&apos;;
import {expect} from &apos;chai&apos;;
</code></pre><p>现在你已经知道如何让纯react组件与Redux Store整合了。</p>
<p>对于一些只有一个根组件且没有路由的小应用，直接连接根组件就足够了。根组件会将状态数据传递给它的子组件。<br>而对于那些使用路由，就像我们的场景，连接每一个路由指向的处理函数是个好主意。但是分别为每个组件编写连接代码并<br>不适合所有的软件场景。我觉得保持组件props尽可能清晰明了是个非常好的习惯，因为它可以让你很容易清楚组件需要哪些数据，<br>你就可以更容易管理那些连接代码。</p>
<p>现在让我们开始把Redux数据对接到UI里，我们再也不需要那些<code>App.jsx</code>中手写的硬编码数据了，这样我们的<code>App.jsx</code>将会变得简单：</p>
<pre><code>//src/components/App.jsx

import React from &apos;react&apos;;
import {RouteHandler} from &apos;react-router&apos;;

export default React.createClass({
  render: function() {
    return &lt;RouteHandler /&gt;
  }
});
</code></pre><p>###设置socket.io客户端</p>
<p>现在我们已经创建好了客户端的Redux应用，我们接下来将讨论如何让其与我们之前开发的服务端应用进行对接。</p>
<p>服务端已经准备好接受socket连接，并为其进行投票数据的发送。而我们的客户端也已经可以使用Redux Store很方便的<br>接受数据了。我们剩下的工作就是把它们连接起来。</p>
<p>我们需要使用socket.io从浏览器向服务端创建一个连接，我们可以使用<a href="http://socket.io/docs/client-api/" target="_blank" rel="noopener">socket.io-client库</a>来完成<br>这个目的：</p>
<pre><code>npm install --save socket.io-client
</code></pre><p>这个库赋予了我们连接Socket.io服务端的能力，让我们连接之前写好的服务端，端口号8090（注意使用和后端匹配的端口）：</p>
<pre><code>//src/index.jsx

import React from &apos;react&apos;;
import Router, {Route, DefaultRoute} from &apos;react-router&apos;;
import {createStore} from &apos;redux&apos;;
import {Provider} from &apos;react-redux&apos;;
import io from &apos;socket.io-client&apos;;
import reducer from &apos;./reducer&apos;;
import App from &apos;./components/App&apos;;
import {VotingContainer} from &apos;./components/Voting&apos;;
import {ResultsContainer} from &apos;./components/Results&apos;;

const store = createStore(reducer);
store.dispatch({
  type: &apos;SET_STATE&apos;,
  state: {
    vote: {
      pair: [&apos;Sunshine&apos;, &apos;28 Days Later&apos;],
      tally: {Sunshine: 2}
    }
  }
});

const socket = io(`${location.protocol}//${location.hostname}:8090`);

const routes = &lt;Route handler={App}&gt;
  &lt;Route path=&quot;/results&quot; handler={ResultsContainer} /&gt;
  &lt;DefaultRoute handler={VotingContainer} /&gt;
&lt;/Route&gt;;

Router.run(routes, (Root) =&gt; {
  React.render(
    &lt;Provider store={store}&gt;
      {() =&gt; &lt;Root /&gt;}
    &lt;/Provider&gt;,
    document.getElementById(&apos;app&apos;)
  );
});
</code></pre><p>你必须先确保你的服务端已经开启了，然后在浏览器端访问客户端应用，并检查网络监控，你会发现创建了一个<br>WebSockets连接，并且开始传输Socket.io的心跳包了。</p>
<p>###接受来自服务器端的actions</p>
<p>我们虽然已经创建了个socket.io连接，但我们并没有用它获取任何数据。每当我们连接到服务端或服务端发生<br>状态数据改变时，服务端会发送<code>state</code>事件给客户端。我们只需要监听对应的事件即可，我们在接受到事件通知后<br>只需要简单的对我们的Store指派<code>SET_STATE</code>action即可：</p>
<pre><code>//src/index.jsx

import React from &apos;react&apos;;
import Router, {Route, DefaultRoute} from &apos;react-router&apos;;
import {createStore} from &apos;redux&apos;;
import {Provider} from &apos;react-redux&apos;;
import io from &apos;socket.io-client&apos;;
import reducer from &apos;./reducer&apos;;
import App from &apos;./components/App&apos;;
import {VotingContainer} from &apos;./components/Voting&apos;;
import {ResultsContainer} from &apos;./components/Results&apos;;

const store = createStore(reducer);

const socket = io(`${location.protocol}//${location.hostname}:8090`);
socket.on(&apos;state&apos;, state =&gt;
  store.dispatch({type: &apos;SET_STATE&apos;, state})
);

const routes = &lt;Route handler={App}&gt;
  &lt;Route path=&quot;/results&quot; handler={ResultsContainer} /&gt;
  &lt;DefaultRoute handler={VotingContainer} /&gt;
&lt;/Route&gt;;

Router.run(routes, (Root) =&gt; {
  React.render(
    &lt;Provider store={store}&gt;
      {() =&gt; &lt;Root /&gt;}
    &lt;/Provider&gt;,
    document.getElementById(&apos;app&apos;)
  );
});
</code></pre><p>注意我们移除了<code>SET_STATE</code>的硬编码，我们现在已经不需要伪造数据了。</p>
<p>审视我们的界面，不管是投票还是结果页面，它们都会显示服务端提供的第一对选项。服务端和客户端已经连接上了！</p>
<p>###从react组件中指派actions</p>
<p>我们已经知道如何从Redux Store获取数据到UI中，现在来看看如何从UI中提交数据用于actions。</p>
<p>思考这个问题的最佳场景是投票界面上的投票按钮。之前在写相关界面时，我们假设<code>Voting</code>组件接受一个回调函数props。<br>当用户点击某个按钮时组件将会调用这个回调函数。但我们目前并没有实现这个回调函数，除了在测试代码中。</p>
<p>当用户投票后应该做什么？投票结果应该发送给服务端，这部分我们稍后再说，客户端也需要执行一些逻辑：<br>组件的<code>hasVoted</code>值应该被设置，这样用户才不会反复对同一对选项投票。</p>
<p>这是我们要创建的第二个客户端Redux Action，我们称之为<code>VOTE</code>：</p>
<pre><code>//test/reducer_spec.js

it(&apos;handles VOTE by setting hasVoted&apos;, () =&gt; {
  const state = fromJS({
    vote: {
      pair: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;],
      tally: {Trainspotting: 1}
    }
  });
  const action = {type: &apos;VOTE&apos;, entry: &apos;Trainspotting&apos;};
  const nextState = reducer(state, action);

  expect(nextState).to.equal(fromJS({
    vote: {
      pair: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;],
      tally: {Trainspotting: 1}
    },
    hasVoted: &apos;Trainspotting&apos;
  }));
});
</code></pre><p>为了更严谨，我们应该考虑一种情况：不管什么原因，当<code>VOTE</code>action传递了一个不存在的选项时我们的应用该怎么做：</p>
<pre><code>//test/reducer_spec.js

it(&apos;does not set hasVoted for VOTE on invalid entry&apos;, () =&gt; {
  const state = fromJS({
    vote: {
      pair: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;],
      tally: {Trainspotting: 1}
    }
  });
  const action = {type: &apos;VOTE&apos;, entry: &apos;Sunshine&apos;};
  const nextState = reducer(state, action);

  expect(nextState).to.equal(fromJS({
    vote: {
      pair: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;],
      tally: {Trainspotting: 1}
    }
  }));
});
</code></pre><p>下面来看看我们的reducer如何实现的：</p>
<pre><code>//src/reducer.js

import {Map} from &apos;immutable&apos;;

function setState(state, newState) {
  return state.merge(newState);
}

function vote(state, entry) {
  const currentPair = state.getIn([&apos;vote&apos;, &apos;pair&apos;]);
  if (currentPair &amp;&amp; currentPair.includes(entry)) {
    return state.set(&apos;hasVoted&apos;, entry);
  } else {
    return state;
  }
}

export default function(state = Map(), action) {
  switch (action.type) {
  case &apos;SET_STATE&apos;:
    return setState(state, action.state);
  case &apos;VOTE&apos;:
    return vote(state, action.entry);
  }
  return state;
}
</code></pre><p><code>hasVoted</code>并不会一直保存在状态数据中，每当开始一轮新的投票时，我们应该在<code>SET_STATE</code>action的处理逻辑中<br>检查是否用户是否已经投票，如果还没，我们应该删除掉<code>hasVoted</code>：</p>
<pre><code>//test/reducer_spec.js

it(&apos;removes hasVoted on SET_STATE if pair changes&apos;, () =&gt; {
  const initialState = fromJS({
    vote: {
      pair: [&apos;Trainspotting&apos;, &apos;28 Days Later&apos;],
      tally: {Trainspotting: 1}
    },
    hasVoted: &apos;Trainspotting&apos;
  });
  const action = {
    type: &apos;SET_STATE&apos;,
    state: {
      vote: {
        pair: [&apos;Sunshine&apos;, &apos;Slumdog Millionaire&apos;]
      }
    }
  };
  const nextState = reducer(initialState, action);

  expect(nextState).to.equal(fromJS({
    vote: {
      pair: [&apos;Sunshine&apos;, &apos;Slumdog Millionaire&apos;]
    }
  }));
});
</code></pre><p>根据需要，我们新增一个<code>resetVote</code>函数来处理<code>SET_STATE</code>动作：</p>
<pre><code>//src/reducer.js

import {List, Map} from &apos;immutable&apos;;

function setState(state, newState) {
  return state.merge(newState);
}

function vote(state, entry) {
  const currentPair = state.getIn([&apos;vote&apos;, &apos;pair&apos;]);
  if (currentPair &amp;&amp; currentPair.includes(entry)) {
    return state.set(&apos;hasVoted&apos;, entry);
  } else {
    return state;
  }
}

function resetVote(state) {
  const hasVoted = state.get(&apos;hasVoted&apos;);
  const currentPair = state.getIn([&apos;vote&apos;, &apos;pair&apos;], List());
  if (hasVoted &amp;&amp; !currentPair.includes(hasVoted)) {
    return state.remove(&apos;hasVoted&apos;);
  } else {
    return state;
  }
}

export default function(state = Map(), action) {
  switch (action.type) {
  case &apos;SET_STATE&apos;:
    return resetVote(setState(state, action.state));
  case &apos;VOTE&apos;:
    return vote(state, action.entry);
  }
  return state;
}
</code></pre><p>我们还需要在修改一下连接逻辑：</p>
<pre><code>//src/components/Voting.jsx

function mapStateToProps(state) {
  return {
    pair: state.getIn([&apos;vote&apos;, &apos;pair&apos;]),
    hasVoted: state.get(&apos;hasVoted&apos;),
    winner: state.get(&apos;winner&apos;)
  };
}
</code></pre><p>现在我们依然需要为<code>Voting</code>提供一个<code>vote</code>回调函数，用来为Sotre指派我们新增的action。我们依然要尽力保证<br><code>Voting</code>组件的纯粹性，不应该依赖任何actions或Redux。这些工作都应该在react-redux的<code>connect</code>中处理。</p>
<p>除了连接输入参数属性，react-redux还可以用来连接output actions。开始之前，我们先来介绍一下另一个Redux的<br>核心概念：Action creators。</p>
<p>如我们之前看到的，Redux actions通常就是一个简单的对象，它包含一个固有的<code>type</code>属性和其它内容。我们之前都是直接<br>利用js对象字面量来直接声明所需的actions。其实可以使用一个factory函数来更好的生成actions，如下：</p>
<pre><code>function vote(entry) {
  return {type: &apos;VOTE&apos;, entry};
}
</code></pre><p>这类函数就被称为action creators。它们就是个纯函数，用来返回action对象，别的没啥好介绍得了。但是你也可以<br>在其中实现一些内部逻辑，而避免将每次生成action都重复编写它们。使用action creators可以更好的表达所有需要分发<br>的actions。</p>
<p>让我们新建一个用来声明客户端所需action的action creators文件：</p>
<pre><code>//src/action_creators.js

export function setState(state) {
  return {
    type: &apos;SET_STATE&apos;,
    state
  };
}

export function vote(entry) {
  return {
    type: &apos;VOTE&apos;,
    entry
  };
}
</code></pre><p>我们当然也可以为action creators编写测试代码，但由于我们的代码逻辑太简单了，我就不再写测试了。</p>
<p>现在我们可以在<code>index.jsx</code>中使用我们刚新增的<code>setState</code>action creator了：</p>
<pre><code>//src/index.jsx

import React from &apos;react&apos;;
import Router, {Route, DefaultRoute} from &apos;react-router&apos;;
import {createStore} from &apos;redux&apos;;
import {Provider} from &apos;react-redux&apos;;
import io from &apos;socket.io-client&apos;;
import reducer from &apos;./reducer&apos;;
import {setState} from &apos;./action_creators&apos;;
import App from &apos;./components/App&apos;;
import {VotingContainer} from &apos;./components/Voting&apos;;
import {ResultsContainer} from &apos;./components/Results&apos;;

const store = createStore(reducer);

const socket = io(`${location.protocol}//${location.hostname}:8090`);
socket.on(&apos;state&apos;, state =&gt;
  store.dispatch(setState(state))
);

const routes = &lt;Route handler={App}&gt;
  &lt;Route path=&quot;/results&quot; handler={ResultsContainer} /&gt;
  &lt;DefaultRoute handler={VotingContainer} /&gt;
&lt;/Route&gt;;

Router.run(routes, (Root) =&gt; {
  React.render(
    &lt;Provider store={store}&gt;
      {() =&gt; &lt;Root /&gt;}
    &lt;/Provider&gt;,
    document.getElementById(&apos;app&apos;)
  );
});
</code></pre><p>使用action creators还有一个非常优雅的特点：在我们的场景里，我们有一个需要<code>vote</code>回调函数props的<br><code>Vote</code>组件，我们同时拥有一个<code>vote</code>的action creator。它们的名字和函数签名完全一致（都接受一个用来表示<br>选中项的参数）。现在我们只需要将action creators作为react-redux的<code>connect</code>函数的第二个参数，即可完成<br>自动关联：</p>
<pre><code>//src/components/Voting.jsx

import React from &apos;react/addons&apos;;
import {connect} from &apos;react-redux&apos;;
import Winner from &apos;./Winner&apos;;
import Vote from &apos;./Vote&apos;;
import * as actionCreators from &apos;../action_creators&apos;;

export const Voting = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  render: function() {
    return &lt;div&gt;
      {this.props.winner ?
        &lt;Winner ref=&quot;winner&quot; winner={this.props.winner} /&gt; :
        &lt;Vote {...this.props} /&gt;}
    &lt;/div&gt;;
  }
});

function mapStateToProps(state) {
  return {
    pair: state.getIn([&apos;vote&apos;, &apos;pair&apos;]),
    hasVoted: state.get(&apos;hasVoted&apos;),
    winner: state.get(&apos;winner&apos;)
  };
}

export const VotingContainer = connect(
  mapStateToProps,
  actionCreators
)(Voting);
</code></pre><p>这么配置后，我们的<code>Voting</code>组件的<code>vote</code>参数属性将会与<code>vote</code>aciton creator关联起来。这样当点击<br>某个投票按钮后，会导致触发<code>VOTE</code>动作。</p>
<p>###使用Redux Middleware发送actions到服务端</p>
<p>最后我们要做的是把用户数据提交到服务端，这种操作一般发生在用户投票，或选择跳转下一轮投票时发生。</p>
<p>让我们讨论一下投票操作，下面列出了投票的逻辑：</p>
<ul>
<li>当用户进行投票，<code>VOTE</code>action将产生并分派到客户端的Redux Store中；</li>
<li><code>VOTE</code>actions将触发客户端reducer进行<code>hasVoted</code>状态设置；</li>
<li>服务端监控客户端通过socket.io投递的<code>action</code>，它将接收到的actions分派到服务端的Redux Store;</li>
<li><code>VOTE</code>action将触发服务端的reducer，其会创建vote数据并更新对应的票数。</li>
</ul>
<p>这样来说，我们似乎已经都搞定了。唯一缺少的就是让客户端发送<code>VOTE</code>action给服务端。这相当于两端的<br>Redux Store相互分派action，这就是我们接下来要做的。</p>
<p>那么该怎么做呢？Redux并没有内建这种功能。所以我们需要设计一下何时何地来做这个工作：从客户端发送<br>action到服务端。</p>
<p>Redux提供了一个通用的方法来封装action：<a href="http://rackt.github.io/redux/docs/advanced/Middleware.html" target="_blank" rel="noopener">Middleware</a>。</p>
<p>Redux中间件是一个函数，每当action将要被指派，并在对应的reducer执行之前会被调用。它常用来做像日志收集，<br>异常处理，修整action，缓存结果，控制何时以何种方式来让store接收actions等工作。这正是我们可以利用的。</p>
<p>注意，一定要分清Redux中间件和Redux监听器的差别：中间件被用于action将要指派给store阶段，它可以修改action对<br>store将带来的影响。而监听器则是在action被指派后，它不能改变action的行为。</p>
<p>我们需要创建一个“远程action中间件”，该中间件可以让我们的action不仅仅能指派给本地的store，也可以通过<br>socket.io连接派送给远程的store。</p>
<p>让我们创建这个中间件，It is a function that takes a Redux store, and returns another function that takes a “next” callback. That function returns a third function that takes a Redux action. The innermost function is where the middleware implementation will actually go<br>（译者注：这句套绕口，请看官自行参悟）：</p>
<pre><code>//src/remote_action_middleware.js

export default store =&gt; next =&gt; action =&gt; {

}
</code></pre><p>上面这个写法看着可能有点渗人，下面调整一下让大家好理解：</p>
<pre><code>export default function(store) {
    return function(next) {
        return function(action) {

        }
    }
}
</code></pre><p>这种嵌套接受单一参数函数的写法成为<a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="noopener">currying</a>。<br>这种写法主要用来简化中间件的实现：如果我们使用一个一次性接受所有参数的函数（<code>function(store, next, action) { }</code>），<br>那么我们就不得不保证我们的中间件具体实现每次都要包含所有这些参数。</p>
<p>上面的<code>next</code>参数作用是在中间件中一旦完成了action的处理，就可以调用它来退出当前逻辑：</p>
<pre><code>//src/remote_action_middleware.js

export default store =&gt; next =&gt; action =&gt; {
  return next(action);
}
</code></pre><p>如果中间件没有调用<code>next</code>，则该action将丢弃，不再传到reducer或store中。</p>
<p>让我们写一个简单的日志中间件：</p>
<pre><code>//src/remote_action_middleware.js

export default store =&gt; next =&gt; action =&gt; {
  console.log(&apos;in middleware&apos;, action);
  return next(action);
}
</code></pre><p>我们将上面这个中间件注册到我们的Redux Store中，我们将会抓取到所有action的日志。中间件可以通过Redux<br>提供的<code>applyMiddleware</code>函数绑定到我们的store中：</p>
<pre><code>//src/components/index.jsx

import React from &apos;react&apos;;
import Router, {Route, DefaultRoute} from &apos;react-router&apos;;
import {createStore, applyMiddleware} from &apos;redux&apos;;
import {Provider} from &apos;react-redux&apos;;
import io from &apos;socket.io-client&apos;;
import reducer from &apos;./reducer&apos;;
import {setState} from &apos;./action_creators&apos;;
import remoteActionMiddleware from &apos;./remote_action_middleware&apos;;
import App from &apos;./components/App&apos;;
import {VotingContainer} from &apos;./components/Voting&apos;;
import {ResultsContainer} from &apos;./components/Results&apos;;

const createStoreWithMiddleware = applyMiddleware(
  remoteActionMiddleware
)(createStore);
const store = createStoreWithMiddleware(reducer);

const socket = io(`${location.protocol}//${location.hostname}:8090`);
socket.on(&apos;state&apos;, state =&gt;
  store.dispatch(setState(state))
);

const routes = &lt;Route handler={App}&gt;
  &lt;Route path=&quot;/results&quot; handler={ResultsContainer} /&gt;
  &lt;DefaultRoute handler={VotingContainer} /&gt;
&lt;/Route&gt;;

Router.run(routes, (Root) =&gt; {
  React.render(
    &lt;Provider store={store}&gt;
      {() =&gt; &lt;Root /&gt;}
    &lt;/Provider&gt;,
    document.getElementById(&apos;app&apos;)
  );
});
</code></pre><p>如果你重启应用，你将会看到我们设置的中间件会抓到应用触发的action日志。</p>
<p>那我们应该怎么利用中间件机制来完成从客户端通过socket.io连接发送action给服务端呢？在此之前我们肯定需要先<br>有一个连接供中间件使用，不幸的是我们已经有了，就在<code>index.jsx</code>中，我们只需要中间件可以拿到它即可。<br>使用currying风格来实现这个中间件很简单：</p>
<pre><code>//src/remote_action_middleware.js

export default socket =&gt; store =&gt; next =&gt; action =&gt; {
  console.log(&apos;in middleware&apos;, action);
  return next(action);
}
</code></pre><p>这样我们就可以在<code>index.jsx</code>中传入需要的连接了：</p>
<pre><code>//src/index.jsx

const socket = io(`${location.protocol}//${location.hostname}:8090`);
socket.on(&apos;state&apos;, state =&gt;
  store.dispatch(setState(state))
);

const createStoreWithMiddleware = applyMiddleware(
  remoteActionMiddleware(socket)
)(createStore);
const store = createStoreWithMiddleware(reducer);
</code></pre><p>注意跟之前的代码比，我们需要调整一下顺序，让socket连接先于store被创建。</p>
<p>一切就绪了，现在就可以使用我们的中间件发送<code>action</code>了：</p>
<pre><code>//src/remote_action_middleware.js

export default socket =&gt; store =&gt; next =&gt; action =&gt; {
  socket.emit(&apos;action&apos;, action);
  return next(action);
}
</code></pre><p>打完收工。现在如果你再点击投票按钮，你就会看到所有连接到服务端的客户端的票数都会被更新！</p>
<p>还有个很严重的问题我们要处理：现在每当我们收到服务端发来的<code>SET_STATE</code>action后，这个action都将会直接回传给<br>服务端，这样我们就造成了一个死循环，这是非常反人类的。</p>
<p>我们的中间件不应该不加处理的转发所有的action给服务端。个别action，例如<code>SET_STATE</code>，应该只在客户端做<br>处理。我们在action中添加一个标识位用于识别哪些应该转发给服务端：</p>
<pre><code>//src/remote_action_middleware.js

export default socket =&gt; store =&gt; next =&gt; action =&gt; {
  if (action.meta &amp;&amp; action.meta.remote) {
    socket.emit(&apos;action&apos;, action);
  }
  return next(action);
}
</code></pre><p>我们同样应该修改相关的action creators：</p>
<pre><code>//src/action_creators.js

export function setState(state) {
  return {
    type: &apos;SET_STATE&apos;,
    state
  };
}

export function vote(entry) {
  return {
    meta: {remote: true},
    type: &apos;VOTE&apos;,
    entry
  };
}
</code></pre><p>让我们重新审视一下我们都干了什么：</p>
<ol>
<li>用户点击投票按钮，<code>VOTE</code>action被分派；</li>
<li>远程action中间件通过socket.io连接转发该action给服务端；</li>
<li>客户端Redux Store处理这个action，记录本地<code>hasVoted</code>属性；</li>
<li>当action到达服务端，服务端的Redux Store将处理该action，更新所有投票及其票数；</li>
<li>设置在服务端Redux Store上的监听器将改变后的状态数据发送给所有在线的客户端；</li>
<li>每个客户端将触发<code>SET_STATE</code>action的分派；</li>
<li>每个客户端将根据这个action更新自己的状态，这样就保持了与服务端的同步。</li>
</ol>
<p>为了完成我们的应用，我们需要实现下一步按钮的逻辑。和投票类似，我们需要将数据发送到服务端：</p>
<pre><code>//src/action_creator.js

export function setState(state) {
  return {
    type: &apos;SET_STATE&apos;,
    state
  };
}

export function vote(entry) {
  return {
    meta: {remote: true},
    type: &apos;VOTE&apos;,
    entry
  };
}

export function next() {
  return {
    meta: {remote: true},
    type: &apos;NEXT&apos;
  };
}
</code></pre><p><code>ResultsContainer</code>组件将会自动关联action creators中的next作为props：</p>
<pre><code>//src/components/Results.jsx

import React from &apos;react/addons&apos;;
import {connect} from &apos;react-redux&apos;;
import Winner from &apos;./Winner&apos;;
import * as actionCreators from &apos;../action_creators&apos;;

export const Results = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  getPair: function() {
    return this.props.pair || [];
  },
  getVotes: function(entry) {
    if (this.props.tally &amp;&amp; this.props.tally.has(entry)) {
      return this.props.tally.get(entry);
    }
    return 0;
  },
  render: function() {
    return this.props.winner ?
      &lt;Winner ref=&quot;winner&quot; winner={this.props.winner} /&gt; :
      &lt;div className=&quot;results&quot;&gt;
        &lt;div className=&quot;tally&quot;&gt;
          {this.getPair().map(entry =&gt;
            &lt;div key={entry} className=&quot;entry&quot;&gt;
              &lt;h1&gt;{entry}&lt;/h1&gt;
              &lt;div className=&quot;voteCount&quot;&gt;
                {this.getVotes(entry)}
              &lt;/div&gt;
            &lt;/div&gt;
          )}
        &lt;/div&gt;
        &lt;div className=&quot;management&quot;&gt;
          &lt;button ref=&quot;next&quot;
                   className=&quot;next&quot;
                   onClick={this.props.next()}&gt;
            Next
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;;
  }
});

function mapStateToProps(state) {
  return {
    pair: state.getIn([&apos;vote&apos;, &apos;pair&apos;]),
    tally: state.getIn([&apos;vote&apos;, &apos;tally&apos;]),
    winner: state.get(&apos;winner&apos;)
  }
}

export const ResultsContainer = connect(
  mapStateToProps,
  actionCreators
)(Results);
</code></pre><p>彻底完工了！我们实现了一个功能完备的应用。</p>
<p>###课后练习<br>（不翻译）</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:edisondik@gmail.com">kazaff</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://blog.kazaff.me/2015/10/08/译-全栈Redux实战/">https://blog.kazaff.me/2015/10/08/译-全栈Redux实战/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/react/">react</a><a class="post-meta__tags" href="/tags/单元测试/">单元测试</a><a class="post-meta__tags" href="/tags/Immutable-js/">Immutable-js</a><a class="post-meta__tags" href="/tags/Redux/">Redux</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/weichat.png"><div class="post-qr-code__desc">微信打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/alipay.png"><div class="post-qr-code__desc">支付宝打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2015/10/09/译-Redux中间件深入浅出/"><i class="fa fa-chevron-left">  </i><span>［译]深入浅出Redux中间件</span></a></div><div class="next-post pull-right"><a href="/2015/09/10/译-Reactjs性能篇/"><span>［译］Reactjs性能篇</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://blog.kazaff.me/2015/10/08/译-全栈Redux实战/';
  this.page.identifier = '2015/10/08/译-全栈Redux实战/';
  this.page.title = '［译]全栈Redux实战';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'http-blog-kazaff-me' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://http-blog-kazaff-me.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(/img/banner.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2021 By kazaff</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>