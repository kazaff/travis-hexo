title: DDD读书摘录
date: 2020-11-20 09:37:12
tags:
- 领域建模
- 微服务
- 读写分离

categories: 架构
---

最近在复习 领域驱动设计 相关的知识，主要是因为越发的觉得DDD思想和方法论能帮助自己甄别好坏以及辅助设计。
很早之前就读过DDD知识领域相关的“圣经”，但是初读时候并没有悟道太多，打算花时间再把能搜集到的资料整理一下看是否能沉淀更多价值出来。
索性全部记录在这篇博文中，方便自己日后复习和查证。目前没有想好要以如何结构来编排内容，暂时都一股脑的记录下来，以后有好的归纳想法后再调整吧，如果觉得阅读起来很乱，不妨试试用关键词检索的方式来抓取内容。


---

### 领域建模的步骤

![](https://pic.yupoo.com/kazaff_v/60fc9af4/big.jpg)

0. 在事件风暴中梳理业务过程中的用户操作、事件以及外部依赖关系等，根据这些要素梳理出领域实体等领域对象。
1. 根据领域实体之间的业务关联性，将业务紧密相关的实体进行组合形成聚合，同时确定聚合中的聚合根、值对象和实体。在这个图里，聚合之间的边界是第一层边界，它们在同一个微服务实例中运行，这个边界是逻辑边界，所以用虚线表示。
2. 根据业务及语义边界等因素，将一个或者多个聚合划定在一个限界上下文内，形成领域模型。在这个图里，限界上下文之间的边界是第二层边界，这一层边界可能就是未来微服务的边界，不同限界上下文内的领域逻辑被隔离在不同的微服务实例中运行，物理上相互隔离，所以是物理边界，边界之间用实线来表示。


### DDD与微服务的关系

DDD是一种架构设计方法，微服务是一种架构风格。

DDD主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。

微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。


### 领域，子域，核心域，通用域，支撑域
**领域**：在研究和解决业务问题时，DDD会按照一定的规则将业务领域进行细分，当领域细分到一定的程度后，DDD会将问题范围限定在特定的边界内，在这个边界内建立领域模型，进而用代码实现该领域模型，解决相应的业务问题。简言之，`DDD的领域就是这个边界内要解决的业务问题域`。

**子域**: 领域可以进一步划分为子领域。我们把划分出来的多个子领域称为子域，`每个子域对应一个更小的问题域或更小的业务范围`。

**核心域**：决定产品和公司核心竞争力的子域是核心域，它是业务成功的主要因素和公司的核心竞争力。

**通用域**：没有太多个性化的诉求，同时被多个子域使用的通用功能子域是通用域。

**支撑域**：既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域，但这些功能子域又是必须的，那它们就是支撑域。

> 举个实际的例子，我们将桃树细分为了根、茎、叶、花、果实和种子等六个子域，那桃树是否有核心域？有的话，到底哪个是核心域呢？
>
> 不同的人对桃树的理解是不同的。如果这棵桃树生长在公园里，在园丁的眼里，他喜欢的是“人面桃花相映红”的阳春三月，这时花就是桃树的核心域。但如果这棵桃树生长在果园里，对果农来说，他则是希望在丰收的季节收获硕果累累的桃子，这时果实就是桃树的核心域。

### 限界上下文

**限界上下文**：用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，`没有二义性`。这个边界定义了模型的适用范围，使团队所有成员能够明确地知道什么应该在模型中实现，什么不应该在模型中实现。`领域边界就是通过限界上下文来定义的，将限界上下文内的领域模型映射到微服务，就完成了从问题域到软件的解决方案。`。理想情况下，子域和限界上下文是重合的，但`子域可能会包含多个限界上下文`。

限界上下文所界定的边界，究竟是逻辑边界，还是物理边界？这并没有定论，需得依据不同场景而做出不同的决策。

- 逻辑边界：所有的限界上下文都部署在同一个进程中，因此不能针对某一个限界上下文进行水平伸缩。`编写代码时，我们需要谨守这条无形的逻辑边界，时刻注意不要逾界，并确定限界上下文各自对外公开的接口，避免对具体的实现产生依赖`。

- 物理边界：每个限界上下文就变成了一个个细粒度的微服务。可以保证边界内的服务、基础设施乃至于存储资源、中间件等其他外部资源的完整性，最终形成自治的服务。限界上下文之间仅仅通过限定的方式以限定的通信协议和数据格式进行通信，除此之外，彼此没有任何共享。但是运维与监控的复杂度也随之而剧增。

### 聚合，聚合根，实体，值对象

**实体**：有ID标识，通过ID判断相等性，ID在聚合内唯一即可。对这些对象而言，重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至超出软件的生命周期。我们把这样的对象称为实体。在DDD里，这些实体类通常采用`充血模型，与这个实体相关的所有业务逻辑都在实体类的方法中实现，跨多个实体的领域逻辑则在领域服务中实现`。

**值对象**：无ID，不可变，无生命周期，用完即扔。`值对象只是若干个属性的集合，只有数据初始化操作和有限的不涉及修改数据的行为，基本不包含业务逻辑。值对象的属性集虽然在物理上独立出来了，但在逻辑上它仍然是实体属性的一部分，用于描述实体的特征`。在值对象中也有部分共享的标准类型的值对象，它们有自己的限界上下文，有自己的持久化对象，可以建立共享的数据类微服务，比如数据字典。

**聚合**：由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。聚合有一个聚合根和`上下文边界，这个边界根据业务单一职责和高内聚原则，定义了聚合内部应该包含哪些实体和值对象，而聚合之间的边界是松耦合的`。聚合内实体以`充血模型`实现个体业务能力，以及业务逻辑的高内聚。`跨多个实体的业务逻辑通过领域服务来实现，跨多个聚合的业务逻辑通过应用服务来实现`。

**聚合根**：聚合根的主要目的是为了避免由于复杂数据模型`缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题`。首先它作为实体本身，拥有实体的属性和业务行为，实现自身的业务逻辑。其次它作为聚合的管理者，在聚合内部负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑。最后在聚合之间，它还是聚合对外的接口人，以聚合根ID关联的方式接受外部任务和请求，在上下文内实现聚合之间的业务协同。也就是说，聚合之间通过聚合根ID关联引用，如果需要访问其它聚合的实体，就要先访问聚合根，再导航到聚合内部实体，外部对象不能直接访问聚合内实体。

#### 怎么设计聚合

![](https://pic.yupoo.com/kazaff_v/68f0df11/big.png)

**第5步**：多个聚合根据业务语义和上下文一起划分到同一个限界上下文内。

> 需要说明一下：投保人和被保人的数据，是通过关联客户ID从客户聚合中获取的，在投保聚合里它们是投保单的值对象，这些值对象的数据是客户的冗余数据，即使未来客户聚合的数据发生了变更，也不会影响投保单的值对象数据。从图中我们还可以看出实体之间的引用关系，比如在投保聚合里投保单聚合根引用了报价单实体，报价单实体则引用了报价规则子实体。

判断一个实体是否是聚合根，可以结合分析：
- 是否有独立的生命周期？是否有全局唯一ID？
- 是否可以创建或修改其它对象？
- 是否有专门的模块来管这个实体？

#### 聚合的一些设计原则

- `在一致性边界内建模真正的不变条件。`聚合内有一套不变的业务规则，各实体和值对象按照统一的业务规则运行，实现对象数据的一致性，边界之外的任何东西都与该聚合无关，这就是聚合能实现业务高内聚的原因。
- `设计小聚合。`如果聚合设计得过大，聚合会因为包含过多的实体，导致实体之间的管理过于复杂，高频操作时会出现并发冲突或者数据库锁，最终导致系统可用性变差。
- `通过唯一标识引用其它聚合。`聚合之间是通过关联外部聚合根ID的方式引用，而不是直接对象引用的方式。外部聚合的对象放在聚合边界内管理，容易导致聚合的边界不清晰，也会增加聚合之间的耦合度。
- `在边界之外使用最终一致性。`在一次事务中，最多只能更改一个聚合的状态。如果一次业务操作涉及多个聚合状态的更改，应采用领域事件的方式异步修改相关的聚合，实现聚合之间的解耦。
- `通过应用层实现跨聚合的服务调用。`应避免跨聚合的领域服务调用和跨聚合的数据库表关联。

### 领域事件

领域事件驱动设计可以切断领域模型之间的强依赖关系，事件发布完成后，发布方不必关心后续订阅方事件处理是否成功，这样可以实现领域模型的解耦，维护领域模型的独立性和数据的一致性。在领域模型映射到微服务系统架构时，领域事件可以解耦微服务，微服务之间的数据不必要求强一致性，而是基于事件的最终一致性。

![](https://pic.yupoo.com/kazaff_v/aaafe0ca/big.jpg)

### 应用服务，领域服务

**应用服务**：位于应用层。应用服务会对多个领域服务或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务，是一段独立的业务逻辑。

**领域服务**：位于领域层。领域服务封装核心的业务逻辑，实现需要多个实体协作的核心领域逻辑。它对多个实体或方法的业务逻辑进行组合或编排，或者在严格分层架构中对实体方法进行封装，以领域服务的方式供应用层调用。所以如果有的实体方法需要被前端应用调用，我们会将它封装成领域服务，然后再封装为应用服务。
为隐藏领域层的业务逻辑实现，所有领域方法和服务等均须通过领域服务对外暴露。
为实现微服务内聚合之间的解耦，`原则上禁止领域服务进行跨聚合的编排和跨聚合的数据相互关联`。

![](https://pic.yupoo.com/kazaff_v/d41518d5/big.png)


### DDD分层

![](https://pic.yupoo.com/kazaff_v/3179ec83/big.jpg)

DDD分层架构有一个重要的原则：`每层只能与位于其下方的层发生耦合`。

![](https://pic.yupoo.com/kazaff_v/070cd763/big.jpg)

![](https://pic.yupoo.com/kazaff_v/c526409c/big.png)


### 数据视图

数据视图应用服务通过数据传输对象（DTO）完成外部数据交换。领域层通过领域对象（DO）作为领域实体和值对象的数据和行为载体。基础层利用持久化对象（PO）完成数据库的交换。

DTO 与 VO 通过 Restful 协议实现 JSON 格式和对象转换。

前端应用与应用层之间 DTO 与 DO 的转换发生在用户接口层。如微服务内应用服务需调用外部微服务的应用服务，则 DTO 的组装和 DTO 与 DO 的转换发生在应用层。

领域层 DO 与 PO 的转换发生在基础层。

![](https://pic.yupoo.com/kazaff_v/229c0258/3e5f9377.png)


### DDD中的读操作

在DDD的写操作中，我们需要严格地按照 “ 应用服务 -> 聚合根 -> 资源库 ” 的结构进行编码，而在读操作中，采用与写操作相同的结构有时不但得不到好处，反而使整个过程变得冗繁。常见的3种读操作的方式：

- 基于领域模型的读操作 
  - 读操作完全束缚于聚合根的边界划分；
  - 导致的结果是Repository上处理了太多的查询逻辑，变得越来越复杂，也逐渐偏离了Repository本应该承担的职责
- 基于数据模型的读操作
  - 由于读操作和写操作共享了数据库，而此时的数据库主要是对应于聚合根的结构创建的，因此读操作依然会受到写操作的数据模型的牵制
- CQRS
  - 复杂度高(与“基于数据模型的读操作”不同的是，在CQRS中写操作和读操作使用了不同的数据库，数据从写模型数据库同步到读模型数据库，通常通过领域事件的形式同步变更信息)
  - 数据一致性 受 数据同步策略影响

![](https://pic.yupoo.com/kazaff_v/dd567e74/fe9b35b5.png)



---

# 参考文献

- [《DDD实战课》](https://time.geekbang.org/column/intro/238)
- [限界上下文的边界](https://zhuanlan.zhihu.com/p/31985410)
- [领域驱动设计(DDD)编码实践](https://mp.weixin.qq.com/s/g1i04xjUgkqLOqtTeFukgQ)
- [基于DDD的微服务设计和开发实战](https://www.infoq.cn/article/s_LFUlU6ZQODd030RbH9)
- [细数软件架构中的解耦](https://www.infoq.cn/article/8hlh2qEWP1Y00qumdMQj)